{{COI|date=July 2018}}
{{intromissing|date=May 2024}}
{{Evolutionary algorithms}}
== History ==

The Fly Algorithm is a type of [[cooperative coevolution]] based on the Parisian approach.<ref name=Collet2009>{{cite book |title=Optimization in Signal and Image Processing|chapter=Artificial evolution and the Parisian approach: applications in the processing of signals and images|last2=Louchet|first2=Jean|last1=Collet|first1=Pierre|publisher=Wiley-ISTE|date=Oct 2009|isbn=9781848210448|editor1-last=Siarry|editor1-first=Patrick}}</ref> The Fly Algorithm has first been developed in 1999 in the scope of the application of [[Evolutionary algorithms]] to [[computer stereo vision]].<ref name=LouchetRFIA2000>{{cite conference |title=L'algorithme des mouches : une stratégie d'évolution individuelle appliquée en stéréovision|last1=Louchet|first1=Jean|conference=Reconnaissance des Formes et Intelligence Artificielle (RFIA2000)|date=Feb 2000}}</ref><ref name=Louchet2000ICPR>{{cite conference |title=Stereo analysis using individual evolution strategy|last1=Louchet|first1=Jean|publisher=IEEE|conference=Proceedings of 15th International Conference on Pattern Recognition, 2000 (ICPR’00)|pages=908–911|date=Sep 2000|doi=10.1109/ICPR.2000.905580|isbn=0-7695-0750-6|location=Barcelona, Spain}}</ref> Unlike the classical image-based approach to stereovision, which extracts image primitives then matches them in order to obtain 3-D information, the Fly Agorithm is based on the direct exploration of the 3-D space of the scene. A fly is defined as a 3-D point described by its coordinates (''x'', ''y'', ''z''). Once a random population of flies has been created in a search space corresponding to the field of view of the cameras, its evolution (based on the Evolutionary Strategy paradigm) used a [[fitness function]] that evaluates how likely the fly is lying on the visible surface of an object, based on the consistency of its image projections. To this end, the fitness function uses the grey levels, colours and/or textures of the calculated fly's projections.

The first application field of the Fly Algorithm has been stereovision.<ref name=LouchetRFIA2000 /><ref name=Louchet2000ICPR /><ref name=Louchet2001>{{cite journal |title=Using an Individual Evolution Strategy for Stereovision|last1=Louchet|first1=Jean|pages=101–109|date=Jun 2001|doi=10.1023/A:1011544128842|volume=2|issue=2|journal=Genetic Programming and Evolvable Machines|s2cid=8953837}}</ref><ref name=Boumaza2003>{{cite conference |title=Mobile robot sensor fusion using flies|last1=Boumaza|first1=Amine|last2=Louchet|first2=Jean|publisher=Springer|conference=European Conference on Genetic Programming (EuroGP 2003)|pages=357–367|date=Apr 2003|doi=10.1007/3-540-36605-9_33|isbn=978-3-540-00976-4|location=Essex, UK|volume=2611|book-title=Lecture Notes on Computer Science}}</ref> While classical `image priority' approaches use matching features from the stereo images in order to build a 3-D model, the Fly Algorithm directly explores the 3-D space and uses image data to evaluate the validity of 3-D hypotheses. A variant called the "Dynamic Flies" defines the fly as a 6-uple (''x'', ''y'', ''z'', ''x’'', ''y’'', ''z’'') involving the fly's velocity.<ref name=Louchet2002>{{cite book |title=Apprentissage Automatique et Evolution Artificielle|chapter=L’algorithme des mouches dynamiques: guider un robot par évolution artificielle en temps réel|last1=Louchet|first1=Jean|last2=Guyon|first2=Maud|last3=Lesot|first3=Marie-Jeanne|last4=Boumaza|first4=Amine|publisher=Hermes Sciences Publications|date=Mar 2002|isbn=978-2746203600|language=fr|chapter-url=http://jean.louchet.free.fr/publis/2001ECA.pdf|editor1-last=Lattaud|editor1-first=Claude}}</ref><ref name=Louchet2002PatterRec>{{cite journal |title=Dynamic Flies: a new pattern recognition tool applied to stereo sequence processing|last1=Louchet|first1=Jean|last2=Guyon|first2=Maud|last3=Lesot|first3=Marie-Jeanne|last4=Boumaza|first4=Amine|pages=335–345|date=Jan 2002|doi=10.1016/S0167-8655(01)00129-5|volume=23|issue=1–3|journal=Pattern Recognition Letters|bibcode=2002PaReL..23..335L |url=http://jean.louchet.free.fr/publis/2001PRL.pdf}}</ref> The velocity components are not explicitly taken into account in the fitness calculation but are used in the flies' positions updating and are subject to similar genetic operators (mutation, crossover).

The application of Flies to obstacle avoidance in vehicles<ref name=Bomaza2001EvoIASP>{{cite conference |title=Dynamic Flies: Using Real-time evolution in Robotics|last1=Boumaza|first1=Amine|last2=Louchet|first2=Jean|publisher=Springer|conference=Artificial Evolution in Image Analysis and Signal Processing (EVOIASP2001)|pages=288–297|date=Apr 2001|doi=10.1007/3-540-45365-2_30|isbn=978-3-540-41920-4|location=Como, Italy|volume=2037|book-title=Lecture Notes on Computer Science}}</ref> exploits the fact that the population of flies is a time compliant, quasi-continuously evolving representation of the scene to directly generate vehicle control signals from the flies. The use of the Fly Algorithm is not strictly restricted to stereo images, as other sensors may be added (e.g. acoustic proximity sensors, etc.) as additional terms to the fitness function being optimised. Odometry information can also be used to speed up the updating of flies' positions, and conversely the flies positions can be used to provide localisation and mapping information.<ref name=Louchet2009EvoIASP>{{cite conference |title=Flies Open a Door to SLAM.|last1=Louchet|first1=Jean|last2=Sapin|first2=Emmanuel|publisher=Springer|conference=Applications of Evolutionary Computation (EvoApplications 2009)|pages=385–394|date=2009|doi= 10.1007/978-3-642-01129-0_43|location=Tübingen, Germany|volume=5484|book-title=Lecture Notes in Computer Science}}</ref>

Another application field of the Fly Algorithm is reconstruction for emission Tomography in [[nuclear medicine]]. The Fly Algorithm has been successfully applied in [[single-photon emission computed tomography]]<ref name=Bousquet2007EA>{{cite conference |title=Fully Three-Dimensional Tomographic Evolutionary Reconstruction in Nuclear Medicine|last1=Bousquet|first1=Aurélie|last2=Louchet|first2=Jean-Marie|last3=Rocchisani|first3=Jean|publisher=Springer, Heidelberg|conference=Proceedings of the 8th international conference on Artificial Evolution (EA’07)|pages=231–242|date=Oct 2007|doi=10.1007/978-3-540-79305-2_20|isbn=978-3-540-79304-5|location=Tours, France|volume=4926|book-title=Lecture Notes in Computer Science|url=http://jean.louchet.free.fr/publis/EA07Bousquet.pdf}}</ref> and [[positron emission tomography]]<ref name=Vidal2009EA>{{cite conference |title=Artificial evolution for 3D PET reconstruction|last1=Vidal|first1=Franck P.|last2=Lazaro-Ponthus|first2=Delphine|last3=Legoupil|first3=Samuel|first4=Jean|first5=Évelyne|first6=Jean-Marie|last4=Louchet|last5=Lutton|last6=Rocchisani|publisher=Springer, Heidelberg|conference=Proceedings of the 9th international conference on Artificial Evolution (EA’09)|pages=37–48|date=Oct 2009|doi=10.1007/978-3-642-14156-0_4|isbn=978-3-642-14155-3|location=Strasbourg, France|volume=5975|book-title=Lecture Notes in Computer Science|url=http://fly4pet.fpvidal.net/pdf/Vidal2009EA.pdf}}</ref>
.<ref name=Vidal2009MIC>{{cite conference |title=PET reconstruction using a cooperative coevolution strategy in LOR space|last1=Vidal|first1=Franck P.|last2=Louchet|first2=Jean|last3=Lutton|first3=Évelyne|last4=Rocchisani|first4=Jean-Marie|publisher=IEEE|conference=Medical Imaging Conference (MIC)|pages=3363–3366|date=Oct–Nov 2009|doi=10.1109/NSSMIC.2009.5401758|location=Orlando, Florida|book-title=IEEE Nuclear Science Symposium Conference Record (NSS/MIC), 2009}}</ref> Here, each fly is considered a photon emitter and its fitness is based on the conformity of the simulated illumination of the sensors with the actual pattern observed on the sensors. Within this application, the fitness function has been re-defined to use the new concept of 'marginal evaluation'. Here, the fitness of one individual is calculated as its (positive or negative) contribution to the quality of the global population. It is based on the [[Cross-validation (statistics)|leave-one-out cross-validation]] principle. A ''global fitness function'' evaluates the quality of the population as a whole; only then the fitness of an individual (a fly) is calculated as the difference between the global fitness values of the population with and without the particular fly whose ''individual fitness function''  has to be evaluated.<ref name=Vidal2010EvoIASP>{{cite conference |title=New genetic operators in the Fly Algorithm: application to medical PET image reconstruction|last1=Vidal|first1=Franck P.|last2=Louchet|first2=Jean|last4=Lutton|first4=Évelyne|last3=Rocchisani|first3=Jean-Marie|publisher=Springer, Heidelberg|conference=European Workshop on Evolutionary Computation in Image Analysis and Signal Processing (EvoIASP’10)|pages=292–301|date=Apr 2010|doi=10.1007/978-3-642-12239-2_30|isbn=978-3-642-12238-5|location=Istanbul, Turkey|volume=6024|book-title=Lecture Notes in Computer Science|url=http://fly4pet.fpvidal.net/pdf/Vidal2010EvoIASP.pdf}}</ref><ref name=Vidal2010PPSN>{{cite conference |title=Threshold selection, mitosis and dual mutation in cooperative coevolution: application to medical 3D tomography|last1=Vidal|first1=Franck P.|last2=Lutton|first2=Évelyne|last3=Louchet|first3=Jean|last4=Rocchisani|first4=Jean-Marie|publisher=Springer, Heidelberg|conference=International Conference on Parallel Problem Solving From Nature (PPSN'10)|pages=414–423|date=Sep 2010|doi=10.1007/978-3-642-15844-5_42|location=Krakow, Poland|volume=6238|book-title=Lecture Notes in Computer Science|url=http://fly4pet.fpvidal.net/pdf/Vidal2010PPSN.pdf}}</ref> In <ref name=Abbood2017SWEVO>{{cite journal |title=Voxelisation in the 3-D Fly Algorithm for PET|last1=Ali Abbood|first1=Zainab|last2=Lavauzelle|first2=Julien|last3=Lutton|first3=Évelyne|last4=Rocchisani|first4=Jean-Marie|last5=Louchet|first5=Jean|last6=Vidal|first6=Franck P.|date=2017|doi=10.1016/j.swevo.2017.04.001|issn=2210-6502|volume=36|pages=91–105|journal=Swarm and Evolutionary Computation|url=http://fly4pet.fpvidal.net/pdf/Abbood2017SWEVO.pdf}}</ref> the fitness of each fly is considered as a `level of confidence'. It is used during the voxelisation process to tweak the fly's individual footprint using implicit modelling (such as [[metaballs]]). It produces smooth results that are more accurate.

More recently it has been used in digital art to generate mosaic-like images or spray paint.<ref name=Abbood2017EvoIASP>{{cite conference |title=Evolutionary Art Using the Fly Algorithm|last1=Ali Abbood|first1=Zainab|last2=Amlal|first2=Othman|last3=Vidal|first3=Franck P.|publisher=Springer|conference=Applications of Evolutionary Computation (EvoApplications 2017)|pages=455–470|date=Apr 2017|doi=10.1007/978-3-319-55849-3_30|location=Amsterdam, the Netherlands|volume=10199|book-title=Lecture Notes in Computer Science|url=http://fly4pet.fpvidal.net/pdf/Abbood017EvoIASP.pdf}}</ref> Examples of images can be found on [https://www.youtube.com/playlist?list=PLR_5kWb9r72g-XnYdrdJhRle8aGtqX6CE YouTube]
<!--ref>{{cite conference }}</ref-->
<!-- 
<ref name=Vidal2010>{{cite journal |title=Flies for PET: An artificial evolution strategy for image reconstruction in nuclear medicine|last1=Vidal|first1=Franck P.|last4=Lutton|first4=Évelyne|last2=Louchet|first2=Jean|last3=Rocchisani|first3=Jean-Marie|publisher=American Association of Physicists in Medicine|page=3139|date=2010|doi=10.1118/1.3468200|volume=37|issue=6|journal=Medical Physics|url=http://fly4pet.fpvidal.net/pdf/Vidal2010MedPhys-A.pdf}}</ref>
-->

== Parisian evolution ==

Here, the population of individuals is considered as a ''society'' where the individuals collaborate toward a common goal. 
This is implemented using an evolutionary algorithm that includes all the common [[genetic operators]] (e.g. mutation, cross-over, selection). 
The main difference is in the fitness function. 
Here two levels of fitness function are used:
* A local fitness function to assess the performance of a given individual (usually used during the selection process).
* A global fitness function to assess the performance of the whole population. Maximising (or minimising depending on the problem considered) this global fitness is the goal of the population.
In addition, a diversity mechanism is required to avoid individuals gathering in only a few areas of the search space. 
Another difference is in the extraction of the problem solution once the evolutionary loop terminates. In classical evolutionary approaches, the best individual corresponds to the solution and the rest of the population is discarded. 
Here, all the individuals (or individuals of a sub-group of the population) are collated to build the problem solution.
The way the fitness functions are constructed and the way the solution extraction is made are of course problem-dependent.

Examples of Parisian Evolution applications include:
* [http://evelyne.lutton.free.fr/FlyAlgo.html The Fly algorithm].
* [http://evelyne.lutton.free.fr/TextRetrieval.html Text-mining].
* [http://evelyne.lutton.free.fr/HandGesture.html Hand gesture recognition].
* [http://evelyne.lutton.free.fr/Cheese.html Modelling complex interactions in industrial agrifood process].
* [http://fpvidal.net/fly4pet/fly4pet.php Positron Emission Tomography reconstruction].

== Disambiguation ==

=== Parisian approach ''vs'' [[cooperative coevolution]] ===

[[Cooperative coevolution]] is a broad class of [[evolutionary algorithm]]s where a complex problem is solved by decomposing it into subcomponents that are solved independently. 
The Parisian approach shares many similarities with the [[cooperative coevolution|cooperative coevolutionary algorithm]]. The Parisian approach makes use of a single-population whereas multi-species may be used in [[cooperative coevolution|cooperative coevolutionary algorithm]]. 
Similar internal evolutionary engines are considered in classical [[evolutionary algorithm]], [[cooperative coevolution|cooperative coevolutionary algorithm]] and Parisian evolution. 
The difference between [[cooperative coevolution|cooperative coevolutionary algorithm]] and Parisian evolution resides in the population's semantics. 
[[cooperative coevolution|Cooperative coevolutionary algorithm]] divides a big problem into sub-problems (groups of individuals) and solves them separately toward the big problem.<ref name=Mesejo2015>{{cite journal |title=Artificial Neuron – Glia Networks Learning Approach Based on Cooperative Coevolution|last1=Mesejo|first1=Pablo|last2=Ibanez|first2=Oscar|last3=Fernandez-blanco|first3=Enrique|last4=Cedron|first4=Francisco|last5=Pazos|first5=Alejandro|last6=Porto-pazos|first6=Ana|pages=1550012|date=2015|doi=10.1142/S0129065715500124|pmid=25843127|volume=25|issue=4|journal=International Journal of Neural Systems|hdl=2183/17502|s2cid=7653183 |url=https://hal.inria.fr/hal-01221226/file/paperReviewed2.pdf}}</ref> There is no interaction/breeding between individuals of the different sub-populations, only with individuals of the same sub-population. 
However, Parisian [[evolutionary algorithms]] solve a whole problem as a big component. 
All population's individuals cooperate together to drive the whole population toward attractive areas of the search space.

=== Fly Algorithm ''vs'' [[particle swarm optimisation]] ===
[[Cooperative coevolution]] and [[particle swarm optimisation|particle swarm optimisation (PSO)]] share many similarities. [[particle swarm optimisation|PSO]] is inspired by the social behaviour of bird flocking or fish schooling.<ref name=Kennedy1995>{{cite conference |conference=Proceedings of IEEE International Conference on Neural Networks|title=Particle swarm optimization|last1=Kennedy|first1=J|last2=Eberhart|first2=R|publisher=IEEE|date=1995|doi=10.1109/ICNN.1995.488968|pages=1942–1948}}</ref><ref name=Shi1998>{{cite conference |conference=Proceedings of IEEE International Conference on Evolutionary Computation|title=A modified particle swarm optimizer|last1=Shi|first1=Y|last2=Eberhart|first2=R|publisher=IEEE|date=1998|doi=10.1109/ICEC.1998.699146|pages=69–73}}</ref> 
It was initially introduced as a tool for realistic animation in computer graphics. 
It uses complex individuals that interact with each other in order to build visually realistic collective behaviours through adjusting the individuals' behavioural rules (which may use random generators). 
In mathematical optimisation, every particle of the swarm somehow follows its own random path biased toward the best particle of the swarm. 
In the Fly Algorithm, the flies aim at building spatial representations of a scene from actual sensor data; flies do not communicate or explicitly cooperate, and do not use any behavioural model.

Both algorithms are search methods that start with a set of random solutions, which are iteratively corrected toward a global optimum. 
However, the solution of the optimisation problem in the Fly Algorithm is the population (or a subset of the population): The flies implicitly collaborate to build the solution. In [[particle swarm optimisation|PSO]] the solution is a single particle, the one with the best fitness. Another main difference between the Fly Algorithm and with [[particle swarm optimisation|PSO]] is that the Fly Algorithm is not based on any behavioural model but only builds a geometrical representation.

== Applications of the Fly algorithnm ==
* [[Computer stereo vision]]<ref name=LouchetRFIA2000 /><ref name=Louchet2000ICPR /><ref name=Louchet2001 /><ref name=Boumaza2003 />
* [[Obstacle avoidance]]<ref name=Louchet2002 /><ref name=Bomaza2001EvoIASP /><ref name=Louchet2002PatterRec />
* [[Simultaneous localization and mapping|Simultaneous localization and mapping (SLAM)]]<ref name=Louchet2009EvoIASP />
* [[Single-photon emission computed tomography|Single-photon emission computed tomography (SPECT)]] reconstruction <ref name=Bousquet2007EA />
* [[Positron emission tomography|Positron emission tomography (PET)]] reconstruction <ref name=Vidal2009EA /><ref name=Vidal2009MIC /><ref name=Vidal2010EvoIASP /><ref name=Vidal2010PPSN /><ref name=Abbood2017SWEVO /><ref name=Abbood2017EA>{{cite conference |title=Basic, Dual, Adaptive, and Directed Mutation Operators in the Fly Algorithm|last1=Abbood|first1=Zainab Ali|last2=Vidal|first2=Franck P.|conference=13th Biennal International Conference on Artificial Evolution (EA-2017)|pages=106–119|date=2017|location=Paris, France|book-title=Lecture Notes in Computer Science|isbn=978-2-9539267-7-4}}</ref>
* [[Digital art]]<ref name=Abbood2017EvoIASP /><ref name=Abbood2017ArtAndScience>{{cite journal |title=Fly4Arts: Evolutionary Digital Art with the Fly Algorithm|last1=Abbood|first1=Zainab Ali|last2=Vidal|first2=Franck P.|pages=1–6|date=Oct 2017|doi=10.21494/ISTE.OP.2017.0177|volume=17- 1|issue=1|journal=Art and Science|doi-access=free}}</ref>

<!--== Methodology ==
=== Fitness functions ===
=== Initialisation ===
=== Selection ===
=== Genetic operators ===
=== Stopping criteria ===
=== Extraction of the solution ===
-->

== Example: Tomography reconstruction ==
<!-- === Pseudocode === -->

{{multiple image
 | width = 100
 | right
 | image1=
 | caption1=Example of image to reconstruct <math>(f)</math>, which is unknown.
 | image2=sinogram-hot_spheres.png
 | caption2=Sinogram <math>(Y)</math> of <math>f</math>, which is known.
 | image3=
 | caption3=Image reconstructed using the Fly algorithm <math>(\hat{f})</math>.
 | image4=
 | caption4=Sinogram <math>(\hat{Y})</math> of <math>\hat{f}</math>.
 | footer=Example of reconstruction of a hot rod phantom using the Fly Algorithm. 
}}

Tomography reconstruction is an [[inverse problem]] that is often [[ill-posed]] due to missing data and/or noise. The answer to the inverse problem is not unique, and in case of extreme noise level it may not even exist. The input data of a reconstruction algorithm may be given as the [[Radon transform]] or sinogram <math>\left(Y\right)</math> of the data to reconstruct <math>\left(f\right)</math>. <math>f</math> is unknown; <math>Y</math> is known. 
The data acquisition in tomography can be modelled as:

<math>
Y = P[f] + \epsilon
</math>

where <math>P</math> is the system matrix or projection operator and <math>\epsilon</math> corresponds to some [[Shot noise|Poisson noise]]. 
In this case the reconstruction corresponds to the inversion of the [[Radon transform]]:

<math>
f = P^{-1}[Y]
</math>

Note that <math>P^{-1}</math> can account for noise, acquisition geometry, etc. 
The Fly Algorithm is an example of [[iterative reconstruction]]. Iterative methods in [[tomographic reconstruction]] are relatively easy to model:

<math>
    \hat{f} = \operatorname{arg\,min} || Y - \hat{Y}||^2_2
</math>

where <math>\hat{f}</math> is an estimate of <math>f</math>, that minimises an error metrics (here [[Norm (mathematics)|{{math|''ℓ<sup>2</sup>''}}-norm]], but other error metrics could be used) between <math>Y</math> and <math>\hat{Y}</math>. Note that a [[Regularization (mathematics)|regularisation term]] can be introduced to prevent overfitting and to smooth noise whilst preserving edges. 
Iterative methods can be implemented as follows:
[[File:Iterative-algorithm.svg|512x122px|thumb|right|Iterative correction in tomography reconstruction.]]
   (i) The reconstruction starts using an initial estimate of the image (generally a constant image),
   (ii) Projection data is computed from this image,
   (iii) The estimated projections are compared with the measured projections,
   (iv) Corrections are made to correct the estimated image, and
   (v) The algorithm iterates until convergence of the estimated and measured projection sets.

The [[pseudocode]] below is a step-by-step description of the Fly Algorithm for [[tomographic reconstruction]]. The algorithm follows the steady-state paradigm. For illustrative purposes, advanced genetic operators, such as mitosis, dual mutation, etc.<ref>{{cite conference |title=Threshold selection, mitosis and dual mutation in cooperative co-evolution: Application to medical 3D tomography|last1=Vidal|first1=Franck P.|last2=Lutton|first2=Évelyne|last3=Louchet|first3=Jean|last4=Rocchisani|first4=Jean-Marie|publisher=Springer Berlin / Heidelberg|conference=Parallel Problem Solving from Nature - PPSN XI|pages=414–423|date=Sep 2010|doi=10.1007/978-3-642-15844-5_42|isbn=978-3-642-15843-8|location=Kraków, Poland|volume=6238|book-title=Lecture Notes in Computer Science|url=http://www.fpvidal.net/fly4pet/pdf/Vidal2010PPSN.pdf}}</ref><ref>{{cite conference |title=Basic, Dual, Adaptive, and Directed Mutation Operators in the Fly Algorithm|last1=Ali Abbood|first1=Zainab|last2=Vidal|first2=Franck P.|publisher=Springer-Verlag|conference=13th Biennal International Conference on Artificial Evolution|date=Oct 2017|location=Paris, France|book-title=Lecture Notes in Computer Science}}</ref> are ignored. A [[JavaScript]] implementation can be found on [http://www.fpvidal.net/fly4pet/demo.php Fly4PET].

<!-- [[File:Fly4pet.svg|512x616px|thumb|right|Flowchart of the Fly Algorithm for Positron Emission Tomography.]] -->
<!-- [[File:evolutionary_PET_reconstructions.png|299x501px|thumb|right|Example of evolutionary reconstructions at successive resolutions (with ''N'' the number of flies and ''TS'' the time-stamp in minutes).]]-->

 '''algorithm''' fly-algorithm '''is'''
     '''input:''' number of flies (''N''), 
            input projection data (''p''<sub>''reference''</sub>)
     
     '''output:''' the fly population (''F''), 
             the projections estimated from ''F'' (''p''<sub>''estimated''</sub>)
             the 3-D volume corresponding to the voxelisation of ''F'' (''V''<sub>''F''</sub>)
     
     '''postcondition:''' the difference between ''p''<sub>''estimated''</sub> and ''p''<sub>reference</sub> is minimal.
     
     '''START'''
     
  1.   ''// Initialisation''
  2.   ''// Set the position of the ''N'' flies, i.e. create initial guess''
  3.   '''for each''' fly ''i'' '''in''' fly population ''F'' '''do'''
  4.       ''F''(''i'')<sub>x</sub> &larr; random(0, 1)
  5.       ''F''(''i'')<sub>y</sub> &larr; random(0, 1)
  6.       ''F''(''i'')<sub>z</sub> &larr; random(0, 1)
  7.       Add ''F''(''i'')'s projection in ''p''<sub>''estimated''</sub>
  8.   
  9.   ''// Compute the population's performance (i.e. the global fitness)''
 10.   ''G''<sub>''fitness''</sub>(''F'') &larr; ''Error''<sub>metrics</sub>(''p''<sub>''reference''</sub>, ''p''<sub>''estimated''</sub>)
 11.    
 12.   ''f''<sub>''kill''</sub> &larr; Select a random fly of ''F''
 13.    
 14.   Remove ''f''<sub>''kill''</sub>'s contribution from ''p''<sub>''estimated''</sub>
 15.    
 16.   ''// Compute the population's performance without f<sub>kill</sub>''
 17.   ''G''<sub>''fitness''</sub>(''F''-<nowiki/>{''f''<sub>''kill''</sub>}) &larr; ''Error''<sub>metrics</sub>(''p''<sub>''reference''</sub>, ''p''<sub>''estimated''</sub>)
 18.    
 19.   // Compare the performances, i.e. compute the fly's local fitness
 20.   ''L''<sub>''fitness''</sub>(''f''<sub>''kill''</sub>) &larr; ''G''<sub>''fitness''</sub>(''F''-<nowiki/>{''f''<sub>''kill''</sub>}) - ''G''<sub>''fitness''</sub>(''F'')
 21.    
 22.   '''If''' the local fitness is greater than 0, // Thresholded-selection of a bad fly that can be killed
 23.       '''then''' go to Step 26.   ''// f<sub>kill</sub> is a good fly (the population's performance is better when f<sub>kill</sub> is included): we should not kill it''
 24.       '''else''' go to Step 28.   ''// f<sub>kill</sub> is a bad fly (the population's performance is worse when f<sub>kill</sub> is included): we can get rid of it''
 25.    
 26.   Restore the fly's contribution, then go to Step 12.
 27.    
 28.   Select a genetic operator
 29.    
 30.   '''If''' the genetic operator is mutation,
 31.       '''then''' go to Step 34.
 32.       '''else''' go to Step 50.
 33.    
 34.   ''f''<sub>''reproduce''</sub> &larr; Select a random fly of ''F''
 35.    
 14.   Remove ''f''<sub>''reproduce''</sub>'s contribution from ''p''<sub>''estimated''</sub>
 37.    
 38.   ''// Compute the population's performance without f<sub>reproduce</sub>''
 39.   ''G''<sub>''fitness''</sub>(''F''-<nowiki/>{''f''<sub>''reproduce''</sub>}) &larr; ''Error''<sub>metrics</sub>(''p''<sub>''reference''</sub>, ''p''<sub>''estimated''</sub>)
 40.    
 41.   // Compare the performances, i.e. compute the fly's local fitness
 42.   ''L''<sub>''fitness''</sub>(''f''<sub>''reproduce''</sub>) &larr; ''G''<sub>''fitness''</sub>(''F''-<nowiki/>{''f''<sub>''reproduce''</sub>}) - ''G''<sub>''fitness''</sub>(''F'')
 43.    
 44.   Restore the fly's contribution
 45.    
 46.   '''If''' the local fitness is lower than or equal to 0, // Thresholded-selection of a good fly that can reproduce
 47.       '''else''' go to Step 34.   ''// f<sub>reproduce</sub> is a bad fly: we should not allow it to reproduce''
 48.       '''then''' go to Step 53.   ''// f<sub>reproduce</sub> is a good fly: we can allow it to reproduce''
 49.    
 50.   ''// New blood / Immigration''
 51.   Replace ''f''<sub>''kill''</sub> by a new fly with a random position, go to Step 57.
 52.    
 53.   ''// Mutation''
 54.   Copy ''f''<sub>''reproduce''</sub> into ''f''<sub>''kill''</sub>
 55.   Slightly and randomly alter ''f''<sub>''kill''</sub>'s position
 56.    
 57.   Add the new fly's contribution to the population
 58.    
 59.   '''If''' stop the reconstruction,
 60.       '''then''' go to Step 63.
 61.       '''else''' go to Step 10.
 62.    
 63.   ''// Extract solution''
 64.   ''V''<sub>''F''</sub> &larr; voxelisation of ''F''
 65.    
 66.   '''return''' ''V''<sub>''F''</sub>
    
    '''END'''

== Example: Digital arts ==
<!-- [[File:Initial_random_fly_population.png|200x200px|thumb|left|Image of the initial population (random fly positions).]] -->

{{multiple image
 | width = 200
 | right
 | image1=evolutionary_search_Y_Lliwedd_flies.gif
 | caption1=Evolutionary search.
 | image2=Y_Lliwedd_flies.png
 | caption2=Image reconstructed after optimisation using a set of stripes as the pattern for each tile.
}}

In this example, an input image is to be approximated by a set of tiles (for example as in an ancient [[mosaic]]). A tile has an orientation (angle θ), a three colour components (R, G, B), a size (w, h) and a position (x, y, z). If there are ''N'' tiles, there are 9''N'' unknown floating point numbers to guess. In other words for 5,000 tiles, there are 45,000 numbers to find. Using a classical evolutionary algorithm where the answer of the optimisation problem is the best individual, the genome of an individual would be made up of 45,000 genes. This approach would be extremely costly in term of complexity and computing time. The same applies for any classical optimisation algorithm. Using the Fly Algorithm, every individual mimics a tile and can be individually evaluated using its local fitness to assess its contribution to the population's performance (the global fitness). Here an individual has 9 genes instead of 9''N'', and there are ''N'' individuals. It can be solved as a reconstruction problem as follows:

<math>reconstruction = \operatorname{arg\,min} \overset{x<W}{\underset{x=0}{\sum}}\overset{y<H}{\underset{y=0}{\sum}}|input(x,y) - P[F](x,y)|</math>

where <math>input</math> is the input image, <math>x</math> and <math>y</math> are the pixel coordinates along the horizontal and vertical axis respectively, <math>W</math> and <math>H</math> are the image width and height in number of pixels respectively, <math>F</math> is the fly population, and <math>P</math> is a projection operator that creates an image from flies. This projection operator <math>P</math> can take many forms. In her work, Z. Ali Aboodd <ref name=Abbood2017EvoIASP /> uses [[OpenGL]] to generate different effects (e.g. mosaics, or spray paint). For speeding up the evaluation of the fitness functions, [[OpenCL]] is used too.
The algorithm starts with a population <math>F</math> that is randomly generated (see Line 3 in the algorithm above). <math>F</math> is then assessed using the global fitness to compute <math>G_{fitness}(F) = \overset{x<W}{\underset{x=0}{\sum}}\overset{y<H}{\underset{y=0}{\sum}}|input(x,y) - P[F](x,y)|</math> (see Line 10). <math>G_{fitness}</math> is the objective function that has to be minimized.

== See also ==

* [[Mathematical optimization]]
* [[Metaheuristic]]
* [[Search algorithm]]
* [[Stochastic optimization]]
* [[Evolutionary computation]]
* [[Evolutionary algorithm]]
* [[Genetic algorithm]]
* [[Mutation (genetic algorithm)]]
* [[Crossover (genetic algorithm)]]
* [[Selection (genetic algorithm)]]

== References ==
<!-- Inline citations added to your article will automatically display here. See https://en.wikipedia.org/wiki/WP:REFB for instructions on how to add citations. -->
{{reflist}}

{{Evolutionary computation}}
[[Category:Optimization algorithms and methods]]
[[Category:Genetic algorithms]]
[[Category:Evolutionary algorithms]]
[[Category:Heuristics]]
[[Category:Nature-inspired metaheuristics]]
[[Category:Evolutionary computation]]