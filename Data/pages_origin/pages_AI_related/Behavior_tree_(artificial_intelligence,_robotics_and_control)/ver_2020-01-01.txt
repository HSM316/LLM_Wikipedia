{{about|behavior trees in AI, games, control systems and robotics|behavior trees in requirements handling|Behavior tree}}
{{DISPLAYTITLE:Behavior tree (artificial intelligence, robotics and control) }}

A '''Behavior Tree''' is a [[mathematical model]] of [[Automated planning and scheduling|plan]] execution used in [[computer science]], [[robotics]], [[control systems]] and [[Artificial intelligence (video games)|video games]]. They describe switchings between a finite set of tasks in a modular fashion. Their strength comes from their ability to create very complex tasks composed of simple tasks, without worrying how the simple tasks are implemented. Behavior trees present some similarities to [[State machine|hierarchical state machines]] with the key difference that the main building block of a behavior is a task rather than a state. Its ease of human understanding make behavior trees less error prone and very popular in the game developer community. Behavior trees have been shown to generalize several other control architectures.<ref name = "Colledanchise TRO16">Colledanchise Michele, and Ögren Petter 2016. [https://ieeexplore.ieee.org/abstract/document/7790863 How Behavior Trees Modularize Hybrid Control Systems and Generalize Sequential Behavior Compositions, the Subsumption Architecture, and Decision Trees. In IEEE Transactions on Robotics vol.PP, no.99, pp.1-18 (2016)]</ref> <ref name = "Colledanchise BOOK17">Colledanchise Michele, and Ögren Petter 2017. [https://arxiv.org/abs/1709.00084 Behavior Trees in Robotics and AI: An Introduction.]</ref>

[[File:BT search and grasp.png|thumb|right|450px| Behavior tree modelling the search and grasp plan of a two-armed robot.]]

== Background ==

Behavior trees originate from the computer game industry as a powerful tool to [[Behavior model|model the behavior]] of [[non-player character]]s (NPCs).<ref name = "Damian Isla">Isla D. 2005. [https://www.gamasutra.com/view/feature/130663/gdc_2005_proceeding_handling_.php  Handling complexity in the Halo 2 AI. In Game Developers Conference (Vol. 12)]</ref><ref name = "Damian Isla2">Isla D. 2008.  Halo 3-building a better battle. In Game Developers Conference. 2008.</ref><ref name="lim">Lim, C. U., Baumgarten, R., & Colton, S. 2010.  [http://ccg.doc.gold.ac.uk/ccg_old/papers/lim_evogames10.pdf Evolving behaviour trees for the commercial game DEFCON. In Applications of Evolutionary Computation, pp. 100-110. Springer Berlin Heidelberg, 2010.] {{Webarchive|url=https://web.archive.org/web/20140714174430/https://blog.itu.dk/GAES-E2013/files/2013/09/lim_evogames10.pdf |date=2014-07-14 }}</ref>
They have been extensively used in high-profile video games such as [[Halo (series)|Halo]], [[BioShock (series)|Bioshock]], and [[Spore (2008 video game)|Spore]]. Recent works propose behavior trees as a multi-mission control framework for [[Unmanned aerial vehicle|UAV]], complex robots, robotic manipulation, and multi-robot systems.<ref name = "ogren2">Ögren, Petter. [https://www.csc.kth.se/~petter/Publications/ogren2012bt.pdf "Increasing Modularity of UAV Control Systems using Computer Game Behavior Trees." In AIAA Guidance, Navigation and Control Conference, Minneapolis, Minnesota, pp. 13-16. 2012.]</ref><ref name = "colledanchise">Colledanchise Michele, Marzinotto Alejandro, and Ögren Petter.[http://www.csc.kth.se/~miccol/Michele_Colledanchise/Publications_files/ICRA14_cmo_final.pdf  "Performance Analysis of Stochastic BTs." In Robotics and Automation (ICRA), 2014 IEEE International Conference on. 2014.]</ref><ref name = "marzonotto">Marzinotto, Alejandro, Colledanchise Michele, Smith Christian, and Ögren Petter. [http://www.csc.kth.se/~miccol/Michele_Colledanchise/Publications_files/2013_ICRA_mcko.pdf  "Towards a Unified BTs Framework for Robot Control." In Robotics and Automation (ICRA), 2014 IEEE International Conference on. 2014.]</ref><ref name = "Klocker">Klöckner, Andreas. "Interfacing BTs with the World Using Description Logic." In AIAA Guidance, Navigation and Control Conference, Boston, MA. 2013.</ref><ref name = "Klocker2">Klöckner, Andreas. "Behavior Trees for UAV Mission Management." In GI-Jahrestagung, pp. 57-68. 2013.</ref><ref name = "Bagnell">Bagnell, J. Andrew, Felipe Cavalcanti, Lei Cui, Thomas Galluzzo, Martial Hebert, Moslem Kazemi, Matthew Klingensmith et al. "[https://espace.curtin.edu.au/bitstream/handle/20.500.11937/14608/193059_193059.pdf?sequence=2 An integrated system for autonomous robotics manipulation]." In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 2955-2962. IEEE, 2012.</ref>
Behavior trees have now reached the maturity to be treated in Game AI textbooks 
<ref name = "Millington">Millington and Funge ["Artificial Intelligence for Games." CRC Press 2009 ]</ref>
<ref name = "Rabin">S. Rabin ["Game AI Pro" CRC Press 2014 ]</ref>
as well as generic game environments such as PyGame and Unreal Engine (see links below).

== Key concepts ==

A behavior tree is graphically represented as a directed  [[Tree (set theory)|tree]] in which the nodes are classified as root, control flow nodes, or execution nodes (tasks). For each pair of connected nodes the outgoing node is called parent and the incoming node is called child. The root has no parents and exactly one child, the control flow nodes have one parent and at least one child, and the execution nodes have one parent and no children. Graphically, the children of a control flow node are placed below it, ordered from left to right.<ref name = "craft ai">craft ai 2015. [http://www.craft.ai/blog/bt-101-behavior-trees-grammar-basics/  BT 101 – Behavior Trees grammar basics]</ref>

The execution of a behavior tree starts from the root which sends ticks with a certain frequency to its child. A tick is an enabling signal that allows the execution of a child. When the execution of a node in the behavior tree is allowed, it returns to the parent a status '''running''' if its execution has not finished yet, '''success''' if it has achieved its goal, or '''failure''' otherwise.

=== Control flow node ===

A control flow node is used to control the subtasks of which it is composed. A control flow node may be either a selector (fallback) node or a sequence node. They run each of their subtasks in turn. When a subtask is completed and returns its status (success or failure), the control flow node decides whether to execute the next subtask or not.

==== Selector (fallback) node ====

[[File:Fallback in Behavior tree.png|thumb|right|Figure I. Graphical representation of a fallback composition of N tasks.]]

Fallback nodes are used to find and execute the first child that does not fail. A fallback node will return immediately with a status code of success or running when one of its children returns success or running (see Figure I and the pseudocode below). The children are ticked in order of importance, from left to right.

In pseudocode, the algorithm for a fallback composition is:

 1 '''for''' i from 1 to n '''do'''
 2     childstatus ← Tick(child(i))
 3     '''if''' childstatus = running
 4        '''return''' running
 5     '''else if''' childstatus = success
 6        '''return''' success
 7 '''end'''
 8 '''return''' failure

==== Sequence node ====

[[File:Sequence composition in behaviour trees.png|thumb|right|Figure II. Graphical representation of a sequence composition of N tasks.]]
Sequence nodes are used to find and execute the first child that has not yet succeeded. A sequence node will return immediately with a status code of failure or running when one of its children returns failure or running (see Figure II and the pseudocode below). The children are ticked in order, from left to right.

In pseudocode, the algorithm for a sequence composition is:

 1 '''for''' i from 1 to n '''do'''
 2     childstatus ← Tick(child(i))
 3     '''if''' childstatus = running
 4        '''return''' running
 5     '''else if''' childstatus = failure
 6        '''return''' failure
 7 '''end'''
 8 '''return''' success

== Mathematical state space definition ==

In order to apply control theory tools to the analysis of behavior trees,
they can be defined as three-tuple.<ref name="colledanchise2">Colledanchise Michele, and Ögren Petter.[http://www.csc.kth.se/~miccol/Michele_Colledanchise/Publications_files/IROS14_CO.pdf "How Behavior Trees Modularize Robustness and Safety in Hybrid Systems." In Intelligent Robots and Systems (IROS), 2014 IEEE/RSJ International Conference on, IEEE, 2014.]</ref>

<math>
 T_i=\{f_i,r_i, \Delta t\}, 
</math>

where <math> i\in \mathbb{N}</math> is the index of the tree, <math>f_i: \mathbb{R}^n \rightarrow  \mathbb{R}^n</math> is a vector field representing the right hand side of an ordinary difference equation, <math>\Delta t</math> is a time step and 
<math>r_i: \mathbb{R}^n \rightarrow  \{R_i,S_i,F_i\}</math> is the return status, that can be equal to either 
Running <math>R_i</math>,
Success <math>S_i</math>, or
Failure <math>F_i</math>.

'''Note''': A task is degenerate behavior tree with no parent and no child.

=== Behavior tree execution ===

The execution of a behavior tree is described by the following standard ordinary difference equations:

<math>x_{k+t}(t_{k+1})=f_i( x_{k}(t_{k}))  </math>

<math>t_{k+1}=t_{k}+\Delta t </math>

where <math> k\in \mathbb{N}</math> represent the discrete time, and  <math> x \in \mathbb{R}^n  </math> is the state space of the system modelled by the behavior tree.

=== Fallback composition ===

Two behavior trees <math>T_i</math> and <math>T_j</math> can be composed into a more complex behavior tree <math>T_0</math> using a Fallback operator.

<math>T_0=\mbox{fallback}(T_i,T_j).</math>

Then return status <math>r_0</math> and the vector field <math>f_0</math> associated with <math>T_0</math> are defined (for <math>\mathcal{F}_1</math>{{Definition needed|date=January 2019}}) as follows:

<math>
r_0(x_k) = 
\begin{cases}
r_j(x_k) & \text{ if } x_k \in \mathcal{F}_1\\
r_i(x_k) & \text{ otherwise }.
\end{cases}
</math>

<math>
f_0(x_k) = 
\begin{cases}
f_j(x_k) & \text{ if } x_k \in \mathcal{F}_1\\
f_i(x_k) & \text{ otherwise }.
\end{cases}
</math>

=== Sequence composition ===

Two behavior trees <math>T_i</math> and <math>T_j</math> can be composed into a more complex behavior tree <math>T_0</math> using a Sequence operator.

<math>T_0=\mbox{sequence}(T_i,T_j).</math>

Then return status <math>r_0</math> and the vector field <math>f_0</math> associated with <math>T_0</math> are defined (for <math>\mathcal{S}_1</math>{{Definition needed|date=January 2019}}) as follows:

<math>
r_0(x_k) = 
\begin{cases}
r_j(x_k) & \text{ if } x_k \in \mathcal{S}_1\\
r_i(x_k) & \text{ otherwise }.
\end{cases}
</math>

<math>
f_0(x_k) = 
\begin{cases}
f_j(x_k) & \text{ if } x_k \in \mathcal{S}_1\\
f_i(x_k) & \text{ otherwise }.
\end{cases}
</math>

== See also ==
* [[Decision tree]]
* [[Hybrid system]]
* [[Subsumption architecture]]

== References ==
{{reflist}}

== External links ==
* [https://wiki.ros.org/behavior_tree ROS behavior tree library]
* [https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/index.html Unreal Engine 4 behavior tree documentation]
* [https://outforafight.wordpress.com/2014/07/15/behaviour-behavior-trees-for-ai-dudes-part-1/ Behavior trees for AI: How they work]
* [https://www.pirobot.org/blog/0030/ Behavior Trees: Simple yet Powerful AI for your Robot]

{{DEFAULTSORT:Behavior tree}}
[[Category:Automata (computation)]]
[[Category:Models of computation]]
[[Category:Digital electronics]]
[[Category:Artificial intelligence]]
[[Category:Robot control]]
[[Category:Automated planning and scheduling]]
[[Category:Visual programming]]