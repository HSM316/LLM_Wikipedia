{{refimprove|date=October 2012}}
In [[information technology]] a '''reasoning system''' is a [[software system]] that generates conclusions from available [[knowledge]] using [[logic]]al techniques such as [[Deductive reasoning|deduction]] and [[Inductive reasoning|induction]]. Reasoning systems play an important role in the implementation of [[artificial intelligence]] and [[knowledge-based systems]].

By the everyday usage definition of the phrase, all computer systems are reasoning systems in that they all automate some type of logic or decision. In typical use in the [[Information Technology]] field however, the phrase is usually reserved for systems that perform more complex kinds of reasoning. For example, not for systems that do fairly straightforward types of reasoning such as calculating a sales tax or customer discount but making logical inferences about a medical diagnosis or mathematical theorem. Reasoning systems come in two modes: interactive and batch processing. Interactive systems interface with the user to ask clarifying questions or otherwise allow the user to guide the reasoning process. Batch systems take in all the available information at once and generate the best answer possible without user feedback or guidance.<ref>{{cite book|last1=Wos|first1=Larry|last2=Owerbeek|first2=Ross|last3=Ewing|first3=Lusk|last4=Boyle|first4=Jim|title=Automated Reasoning: Introductions and Applications|date=1984|publisher=Prentice Hall|isbn=978-0-13-054453-7|page=[https://archive.org/details/automatedreasoni0000wosl/page/4 4]|url=https://archive.org/details/automatedreasoni0000wosl/page/4}}</ref>

Reasoning systems have a wide field of application that includes [[Scheduling (production processes)|scheduling]], [[Business rules approach|business rule processing]], [[problem solving]], [[complex event processing]], [[intrusion detection]], [[predictive analytics]], [[robotics]], [[computer vision]], and [[natural language processing]].

==History==
The first reasoning systems were theorem provers, systems that represent axioms and statements in First Order Logic and then use rules of logic such as [[modus ponens]] to infer new statements. Another early type of reasoning system were general problem solvers. These were systems such as the [[General Problem Solver]] designed by [[Allen Newell|Newell]] and [[Herb Simon|Simon]]. General problem solvers attempted to provide a generic planning engine that could represent and solve structured problems. They worked by decomposing problems into smaller more manageable sub-problems, solving each sub-problem and assembling the partial answers into one final answer. Another example general problem solver was the [[Soar (cognitive architecture)|SOAR]] family of systems.

In practice these theorem provers and general problem solvers were seldom useful for practical applications and required specialized users with knowledge of logic to utilize. The first practical application of [[automated reasoning]] were [[expert system]]s. Expert systems focused on much more well defined domains than general problem solving such as medical diagnosis or analyzing faults in an aircraft. Expert systems also focused on more limited implementations of logic. Rather than attempting to implement the full range of logical expressions they typically focused on modus-ponens implemented via IF-THEN rules. Focusing on a specific domain and allowing only a restricted subset of logic improved the performance of such systems so that they were practical for use in the real world and not merely as research demonstrations as most previous automated reasoning systems had been. The engine used for automated reasoning in expert systems were typically called [[inference engine]]s. Those used for more general logical inferencing are typically called [[Automated theorem provers|theorem provers]].<ref>{{cite book|last=Hayes-Roth|first=Frederick|title=Building Expert Systems|year=1983|publisher=AddisonWesley|isbn=978-0-201-10686-2|first2=Donald|last2=Waterman|first3=Douglas|last3=Lenat|url=https://archive.org/details/buildingexpertsy00temd}}</ref>

With the rise in popularity of expert systems many new types of automated reasoning were applied to diverse problems in government and industry. Some such as case-based reasoning were off shoots of expert systems research. Others such as constraint satisfaction algorithms were also influenced by fields such as decision technology and linear programming. Also, a completely different approach, one not based on symbolic reasoning but on a connectionist model has also been extremely productive. This latter type of automated reasoning is especially well suited to pattern matching and signal detection types of problems such as text searching and face matching.

==Use of logic==
The term reasoning system can be used to apply to just about any kind of sophisticated [[decision support system]] as illustrated by the specific areas described below. However, the most common use of the term reasoning system implies the computer representation of logic.  Various implementations demonstrate significant variation in terms of [[Formal system|systems of logic]] and formality. Most reasoning systems implement variations of [[Propositional calculus|propositional]] and [[Symbolic logic|symbolic]] ([[Predicate logic|predicate]]) logic.  These variations may be mathematically precise representations of formal logic systems (e.g., [[First-order logic|FOL]]), or extended and [[Hybrid logic|hybrid]] versions of those systems (e.g., Courteous logic<ref>{{cite web |first=Benjamin N. |last=Grosof |title=Courteous Logic Programs: Prioritized Conflict Handling For Rules |date=30 December 1997 |work=IBM Research Report |id=RC 20836 (92273) |url=http://www.research.ibm.com/iagents/paps/rc20836.ps |format=Postscript}}</ref>).   Reasoning systems may explicitly implement additional logic types (e.g., [[Modal logic|modal]], [[Deontic logic|deontic]], [[Temporal logic|temporal]] logics).  However, many reasoning systems implement imprecise and semi-formal approximations to recognised logic systems.  These systems typically support a variety of procedural and semi-[[Declarative programming|declarative]] techniques in order to model different reasoning strategies.  They emphasise pragmatism over formality and may depend on custom extensions and attachments in order to solve real-world problems.

Many reasoning systems employ [[deductive reasoning]] to draw [[inference]]s from available knowledge.  These inference engines support forward reasoning or backward reasoning to infer conclusions via [[modus ponens]].   The [[Recursion|recursive]] reasoning methods they employ are termed ‘[[forward chaining]]’ and ‘[[backward chaining]]’, respectively. Although reasoning systems widely support deductive inference, some systems employ [[Abductive reasoning|abductive]], [[Inductive reasoning|inductive]], [[Defeasible reasoning|defeasible]] and other types of reasoning. [[Heuristic]]s may also be employed to determine acceptable solutions to [[Computational complexity theory#Intractability|intractable problems]].

Reasoning systems may employ the [[closed world assumption]] (CWA) or [[open world assumption]] (OWA).  The OWA is often associated with [[Ontology|ontological]] knowledge representation and the [[Semantic Web]].   Different systems exhibit a variety of approaches to [[negation]].  As well as [[Logical complement|logical]] or [[bitwise complement]], systems may support existential forms of strong and weak negation including [[Negation as failure|negation-as-failure]] and ‘inflationary’ negation (negation of non-[[Ground expression|ground atoms]]).   Different reasoning systems may support [[Monotonic function#Monotonic logic|monotonic]] or [[Non-monotonic logic|non-monotonic]] reasoning, [[Stratification (mathematics)|stratification]] and other logical techniques.

==Reasoning under uncertainty==

Many reasoning systems provide capabilities for reasoning under [[uncertainty]]. This is important when building [[situated]] [[Distributed Multi-Agent Reasoning System|reasoning agents]] which must deal with uncertain representations of the world.  There are several common approaches to handling uncertainty.  These include the use of certainty factors, [[Probability|probabilistic]] methods such as [[Bayesian inference]] or [[Dempster–Shafer theory]], multi-valued (‘[[Fuzzy logic|fuzzy]]’) logic and various [[Connectionism|connectionist]] approaches.<ref>{{cite book |first1=Yoram |last1=Moses |first2=Moshe Y |last2=Vardi |first3=Ronald |last3=Fagin |first4=Joseph Y |last4=Halpern |title=Reasoning About Knowledge |url=https://books.google.com/books?id=xHmlRamoszMC |year=2003 |publisher=MIT Press |isbn=978-0-262-56200-3}}</ref>

==Types of reasoning system==

This section provides a non-exhaustive and informal categorisation of common types of reasoning system.  These categories are not absolute.  They overlap to a significant degree and share a number of techniques, methods and [[algorithm]]s.

===Constraint solvers===
Constraint solvers solve [[constraint satisfaction problem]]s (CSPs).  They support [[constraint programming]].  A [[Constraint (information theory)|constraint]] is a which must be met by any valid [[Problem solving|solution to a problem]].  Constraints are defined declaratively and applied to [[Variable (mathematics)|variables]] within given domains.  Constraint solvers use [[Search algorithm|search]], [[backtracking]] and [[Local consistency|constraint propagation]] techniques to find solutions and determine optimal solutions.  They may employ forms of [[Linear programming|linear]] and [[nonlinear programming]].  They are often used to perform [[Optimization (mathematics)|optimization]] within highly [[Combinatorics|combinatorial]] problem spaces.  For example, they may be used to calculate optimal scheduling, design efficient [[integrated circuit]]s or maximise productivity in a manufacturing process.<ref>{{cite book |first=Robert |last=Schalkoff |title=Intelligent Systems: Principles, Paradigms and Pragmatics: Principles, Paradigms and Pragmatics |url=https://books.google.com/books?id=80FXUtF5kRoC |year=2011 |publisher=Jones & Bartlett Learning |isbn=978-0-7637-8017-3}}
</ref>

===Theorem provers===
[[Automated theorem proving|Theorem provers]] use [[automated reasoning]] techniques to determine [[Mathematical proof|proofs]] of mathematical theorems.  They may also be used to verify existing proofs.  In addition to academic use, typical applications of theorem provers include verification of the correctness of integrated circuits, software programs, engineering designs, etc.

===Logic programs===
[[Logic programming|Logic programs]] (LPs) are [[Computer program|software programs]] written using [[programming language]]s whose [[Language primitive|primitives]] and [[Expression (programming)|expressions]] provide direct representations of constructs drawn from mathematical logic.  An example of a general-purpose logic programming language is [[Prolog]].  LPs represent the direct application of logic programming to solve problems.   Logic programming is characterised by highly declarative approaches based on formal logic, and has wide application across many disciplines.

===Rule engines===
[[Business rules engine|Rule engines]] represent conditional logic as discrete rules.  Rule sets can be managed and applied separately to other functionality.  They have wide applicability across many domains.  Many rule engines implement reasoning capabilities.  A common approach is to implement [[Production system (computer science)|production system]]s to support forward or backward chaining.  Each rule (‘production’) binds a conjunction of [[Clause|predicate clauses]] to a list of executable actions.  At run-time, the rule engine matches productions against facts and executes (‘fires’) the associated action list for each match.  If those actions remove or modify any facts, or assert new facts, the engine immediately re-computes the set of matches.  Rule engines are widely used to model and apply [[business rule]]s, to control [[Decision making|decision-making]] in automated processes and to enforce business and technical policies.

===Deductive classifier===
[[Deductive classifier]]s arose slightly later than rule-based systems and were a component of a new type of artificial intelligence knowledge representation tool known as [[frame language]]s. A frame language describes the problem domain as a set of classes, subclasses, and relations among the classes. It is similar to the [[Object-oriented analysis and design|object-oriented]] model. Unlike object-oriented models however, frame languages have a formal semantics based on first order logic. They utilize this semantics to provide input to the deductive classifier. The classifier in turn can analyze a given model (known as an [[Ontology (computer science)|ontology]]) and determine if the various relations described in the model are consistent. If the ontology is not consistent the classifier will highlight the declarations that are inconsistent. If the ontology is consistent the classifier can then do further reasoning and draw additional conclusions about the relations of the objects in the ontology. For example, it may determine that an object is actually a subclass or instance of additional classes as those described by the user. Classifiers are an important technology in analyzing the ontologies used to describe models in the [[Semantic web]].<ref>{{cite journal|last=MacGregor|first=Robert|title=Using a description classifier to enhance knowledge representation|journal=IEEE Expert|date=June 1991|volume=6|issue=3|doi=10.1109/64.87683|pages=41–46}}</ref>
<ref>{{cite journal|last=Berners-Lee|first=Tim|first2=James|last2=Hendler|first3=Ora|last3=Lassila|title=The Semantic Web A new form of Web content that is meaningful to computers will unleash a revolution of new possibilities|journal=Scientific American|date=May 17, 2001|url=http://www.cs.umd.edu/~golbeck/LBSC690/SemanticWeb.html|doi=10.1038/scientificamerican0501-34|volume=284|issue=5|pages=34–43|url-status=dead|archiveurl=https://web.archive.org/web/20130424071228/http://www.cs.umd.edu/~golbeck/LBSC690/SemanticWeb.html|archivedate=April 24, 2013}}</ref>

===Machine learning systems===
[[Machine learning]] systems evolve their behavior over time based on [[experience]].   This may involve reasoning over observed events or example data provided for training purposes.  For example, machine learning systems may use [[inductive reasoning]] to generate [[Hypothesis|hypotheses]] for observed facts.  Learning systems search for generalised rules or functions that yield results in line with observations and then use these generalisations to control future behavior.

===Case-based reasoning systems===
[[Case-based reasoning]] (CBR) systems provide solutions to problems by analysing similarities to other problems for which known solutions already exist.  They use [[Analogy|analogical]] reasoning to infer solutions based on case histories.  CBR systems are commonly used in customer/[[technical support]] and [[call centre]] scenarios and have applications in [[Manufacturing|industrial manufacture]], [[agriculture]], [[medicine]], [[law]] and many other areas.

===Procedural reasoning systems===
A [[Procedural Reasoning System|procedural reasoning system]] (PRS) uses reasoning techniques to select [[plan]]s from a [[procedural knowledge]] base.  Each plan represents a course of action for achievement of a given [[goal]].  The PRS implements a [[Belief-Desire-Intention software model|belief-desire-intention model]] by reasoning over facts (‘[[belief]]s’) to select appropriate plans (‘[[intention]]s’) for given goals (‘desires’).  Typical applications of PRS include management, monitoring and [[Fault detection and isolation|fault detection]] systems.

==References==
{{Reflist}}

[[Category:Deductive reasoning]]
[[Category:Problem solving]]
[[Category:Automated reasoning]]
[[Category:Inductive reasoning]]
[[Category:Cognitive architecture]]
[[Category:Rule engines]]
[[Category:Expert systems]]
[[Category:Logic programming|*]]
[[Category:Automated theorem proving]]
[[Category:Constraint programming]]
[[Category:Applied machine learning]]
[[Category:Artificial intelligence]]