{{Short description|Dynamic programming language}}
{{Use dmy dates|date=October 2015}}
{{Infobox programming language
| name = Julia
| logo = Julia Programming Language Logo.svg
| logo size = 120px
| logo caption = 
| screenshot = <!-- filename is enough -->
| screenshot caption = 
| paradigm = [[multi-paradigm programming language|Multi-paradigm]]: [[multiple dispatch]] (primary paradigm), [[procedural programming|procedural]], [[functional programming|functional]], [[metaprogramming|meta]], [[multistaged programming|multistaged]]<ref>{{cite web |url=https://medium.com/@acidflask/smoothing-data-with-julia-s-generated-functions-c80e240e05f3#.615wk3dle |title=Smoothing data with Julia's @generated functions |quote=Julia's generated functions are closely related to the multistaged programming (MSP) paradigm popularized by Taha and Sheard, which generalizes the compile time/run time stages of program execution by allowing for multiple stages of delayed code execution. |date=5 November 2015 |access-date=9 December 2015}}</ref>
| released = {{Start date and age|2012}}<ref name="announcement"/>
| designer = [[Jeff Bezanson (programmer)|Jeff Bezanson]], [[Alan Edelman]], [[Stefan Karpinski]], [[Viral B. Shah]]
| developer = [[Jeff Bezanson (programmer)|Jeff Bezanson]], [[Stefan Karpinski]], [[Viral B. Shah]], and other contributors<ref name="license">{{cite web
  | url = https://github.com/JuliaLang/julia/blob/master/LICENSE.md
  | title = LICENSE.md
  | date = September 2017
 | publisher = [[GitHub]]
  }}</ref><ref>{{cite web
  | url = https://github.com/JuliaLang/julia/graphs/contributors
  | title = Contributors to JuliaLang/julia
  | publisher = [[GitHub]]
  }}</ref>
| latest_release_version = {{wikidata|property|reference|edit| Q28974961 | P548=Q2804309 |P348}}
| latest_release_date = {{start date and age|{{wikidata|qualifier| Q28974961 | P548=Q2804309 |P348|P577}}|df=y}} and <br /> {{wikidata|property| Q28974961 | P548=Q15726348 |P348}} [[long-term support|LTS]]<ref>{{Cite web |title=GitHub - JuliaLang/julia at release-1.6 |url=https://github.com/JuliaLang/julia/tree/release-1.6 |access-date=2022-07-19 |website=GitHub |language=en}}</ref><ref>{{Cite web |title=release-1.6: Backports for 1.6.7 by KristofferC · Pull Request #45319 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/45319 |access-date=2022-05-16 |website=GitHub |language=en}}</ref> / {{start date and age|2022|07|19|df=y}}
| latest preview version = 1.9.0-alpha1<ref>{{Cite web |title=Releases · JuliaLang/julia |url=https://github.com/JuliaLang/julia/releases |access-date=2022-11-15 |website=GitHub |language=en}}</ref>
| latest_preview_date = {{start date and age|2022|11|15|df=y}} and 1.8.4<ref>{{Cite web |title=Backports for Julia 1.8.4 by KristofferC · Pull Request #47488 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/47488 |access-date=2022-11-08 |website=GitHub |language=en}}</ref> and 1.9.0-beta1<ref>{{Cite web |title=release-1.9: Backports for julia 1.9.0-alpha2 / 1.9.0-beta1 by KristofferC · Pull Request #47602 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/47602 |access-date=2022-11-17 |website=GitHub |language=en}}</ref> being worked on and 1.10.0-DEV with daily updates<ref>{{Cite web |title=Set VERSION to 1.10.0-DEV by KristofferC · Pull Request #47222 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/47222 |access-date=2022-10-19 |website=GitHub |language=en}}</ref>
| typing = [[Dynamic programming language|Dynamic]],<ref name="Engheim">{{Cite web|last=Engheim|first=Erik|date=2017-11-17|title=Dynamically Typed Languages Are Not What You Think|url=https://erik-engheim.medium.com/dynamically-typed-languages-are-not-what-you-think-ac8d1392b803|access-date=2021-01-27|website=Medium|language=en}}</ref> [[strong and weak typing|strong]],<ref name="Engheim" /> [[nominal type system|nominative]], [[parametric polymorphism|parametric]], [[optional typing|optional]]
| implementations = 
| dialects = 
| influenced by = {{Flatlist}}
* [[C (programming language)|C]]<ref name="announcement"/>
* [[Dylan (programming language)|Dylan]]<ref name="goldilocks">{{cite web |last1=Stokel-Walker |first1=Chris |title=Julia: The Goldilocks language |url=https://increment.com/programming-languages/goldilocks-language-history-of-julia/ |website=Increment |publisher=Stripe |access-date=23 August 2020}}</ref>
* [[Lisp (programming language)|Lisp]]<ref name="announcement"/><!--only the parser implemented by FemtoLisp, a [[Scheme (programming language)|Scheme]]-like implementation (see: "unsupported" "julia --lisp" that invokes it, but its only influence on the language/syntax – Lisp-like macros? Maybe not even Lisp's CLOS "multimethods"? as Dylan with "multiple dispatch" was cut from the list-->
* [[Lua (programming language)|Lua]]<ref name="Introduction">{{Cite web|url=https://docs.julialang.org/en/v1/|title=<!--Chapter: Introduction under --> Home · The Julia Language|website=docs.julialang.org|language=en|access-date=2018-08-15}}</ref>
* [[Wolfram Mathematica|Mathematica]]<ref name="announcement"/> (strictly its [[Wolfram Language]]<ref>{{cite web |url=https://fatiherikli.github.io/programming-language-network/#language:Julia |title=Programming Language Network |publisher=GitHub |access-date=6 December 2016}}</ref><ref>{{Cite web|title=What Should We Call the Language of Mathematica?—Stephen Wolfram Writings|url=https://writings.stephenwolfram.com/2013/02/what-should-we-call-the-language-of-mathematica/|access-date=2021-06-24|website=writings.stephenwolfram.com|language=en}}</ref>)
* [[MATLAB]]<ref name="announcement"/>
* [[Perl]]<ref name="Introduction"/>
* [[Python (programming language)|Python]]<ref name="Introduction"/>
* [[R (programming language)|R]]<ref name="announcement"/>
* [[Ruby (programming language)|Ruby]]<ref name="Introduction"/>
* [[Scheme (programming language)|Scheme]]<ref name="JuliaCon2016">{{cite web |url=http://www.juliacon.org |title=JuliaCon 2016 |publisher=JuliaCon |quote="He has co-designed the programming language Scheme, which has greatly influenced the design of Julia"|access-date=6 December 2016}}</ref>
{{endflatlist}}
| influenced = 
| programming language = Julia, [[C (programming language)|C]],<!--"Remove when C11 is required for C code" https://github.com/JuliaLang/julia/search?utf8=%E2%9C%93&q=C11&type=

"These roughly follows the c11/c++11 memory model [..] The only exception is the GC safepoint and GC state transitions [..] We use the compiler intrinsics to implement a similar API to the c11/c++11" https://github.com/JuliaLang/julia/blob/44f3d7c921cbe50105a54258db2febb65a4b9d44/src/julia_threads.h
--> [[C++]], [[Scheme (programming language)|Scheme]], [[LLVM]]<ref>{{Cite web |title=Building Julia (Detailed) |website=[[GitHub]] |date=September 2017 |url=https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/build/build.md#required-build-tools-and-external-libraries |access-date=2022-05-16}}</ref>
| platform = Tier&nbsp;1: [[x86-64]], [[IA-32]], [[CUDA]] 10.1+<ref>{{Cite web|title=NVIDIA CUDA ⋅ JuliaGPU|url=https://juliagpu.org/cuda/|access-date=2022-01-17|website=juliagpu.org|quote=we have shown the performance to approach and even sometimes exceed that of CUDA C on a selection of applications from the Rodinia benchmark suite}}</ref>/Nvidia GPUs <small>(for Linux and Windows)</small><br /> Tier&nbsp;2: 64-bit [[AArch64|Arm]] (e.g. [[Apple M1]] Macs, while they also have tier 1 support [[#Current and future platforms|using Rosetta]]<ref name="Apple Silicon" />), 32-bit [[Microsoft Windows|Windows]] <small>(64-bit is tier 1)</small><br /> Tier&nbsp;3: 32-bit [[ARM architecture family|Arm]], [[PowerPC]], AMD ([[ROCm]]) GPUs.<br /> Also supports [[oneAPI (compute acceleration)|oneAPI]]/Intel's GPUs and Google's [[tensor processing unit|TPUs]],<ref>{{Cite web|title=External Method Tables by Keno · Pull Request #39697 · JuliaLang/julia|url=https://github.com/JuliaLang/julia/pull/39697|access-date=2021-06-09|website=GitHub|language=en}}</ref> and has web browser support <small>(for [[JavaScript]] and [[WebAssembly]])</small>,<ref name="WebAssembly"/> and can work in [[Android (operating system)|Android]]. For more details see {{Cite web|url=https://julialang.org/downloads/#currently_supported_platforms|title=supported platforms}}
| operating system = [[Linux]], [[macOS]], [[Microsoft Windows|Windows]] and <!-- no longer just community support for --> [[FreeBSD]]
| license = [[MIT License|MIT]] (core),<ref name="license"/><!--for core language while, by default, "the environment, which consists of the language, user interfaces, and libraries, is under the GPL"--> [[GNU General Public License|GPL v2]];<ref>{{Cite web |title=julia/julia.spdx.json |website=[[GitHub]] |date=September 2017 |url=https://github.com/JuliaLang/julia/blob/7b395153e80672f8cdb18f51dd653a85e28b2070/julia.spdx.json |access-date=2022-05-16}}</ref><ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/v4OjEK7azBs |title=Non-GPL Julia? |website=Groups.google.com |access-date=2017-05-31}}</ref><!--as some few libraries used by the standard library (that can be excluded) are [[copyleft]]--> a [[makefile]] option omits GPL libraries<ref>{{cite web |url=https://github.com/JuliaLang/julia/pull/10870 |title=Introduce USE_GPL_LIBS Makefile flag to build Julia without GPL libraries |website=[[GitHub]] |quote=Note that this commit does not remove GPL utilities such as git and busybox that are included in the Julia binary installers on Mac and Windows.<!--dropped as of 0.5 then only libgit2--> It allows building from source with no GPL library dependencies.}}</ref>
| file ext = .jl
| website = {{Official website|https://JuliaLang.org|name=JuliaLang.org}}
}}

'''Julia''' is a [[high-level programming language|high-level]], [[dynamic programming language|dynamic]] [[programming language]]. Its features are well suited for [[numerical analysis]] and [[computational science]].<ref>{{cite web
  | date        = 15 October 2012
  | last        = Bryant
  | first       = Avi
  | title       = Matlab, R, and Julia: Languages for data analysis
  | url         = http://radar.oreilly.com/2012/10/matlab-r-julia-languages-for-data-analysis.html
  | archive-url = https://web.archive.org/web/20140426110631/https://strata.oreilly.com/2012/10/matlab-r-julia-languages-for-data-analysis.html
  | archive-date= 2014-04-26
  | publisher   = O'Reilly Strata
  }}</ref><ref>{{cite web
  | date        = 23 August 2015
  | last        = Singh
  | first       = Vicky
  | title       = Julia Programming Language – A True Python Alternative
  | url         = https://www.technotification.com/2018/08/julia-programming-language.html
  | publisher   = Technotification
  }}</ref><ref name="infoworld">{{cite magazine
  | last        = Krill
  | first       = Paul
  | title       = New Julia language seeks to be the C for scientists
  | url         = https://www.infoworld.com/article/2616709/new-julia-language-seeks-to-be-the-c-for-scientists.html
  | magazine    = InfoWorld
  | date        = 18 April 2012
  }}</ref><ref>{{cite magazine
  | last        = Finley
  | first       = Klint
  | title       = Out in the Open: Man Creates One Programming Language to Rule Them All
  | url         = https://www.wired.com/2014/02/julia/
  | magazine    = Wired
  | date        = 3 February 2014
  }}</ref>

Distinctive aspects of Julia's design include a type system with [[parametric polymorphism]] in a dynamic programming language; with [[multiple dispatch]] as its core [[programming paradigm]]. Julia supports [[concurrent computing|concurrent]], (composable) [[parallel computing|parallel]] and [[distributed computing]] (with or without using [[Message Passing Interface|MPI]]<ref>{{cite web|title=GitHub - JuliaParallel/MPI.jl: MPI wrappers for Julia.|url=https://github.com/JuliaParallel/MPI.jl|publisher=Parallel Julia|access-date=2019-09-22}}</ref> or the built-in corresponding{{clarify|date=July 2020}}<ref>{{Cite web|url=https://discourse.julialang.org/t/questions-about-getting-started-with-parallel-computing/25341/3?u=palli|title=Questions about getting started with parallel computing|date=2019-06-16|website=JuliaLang|language=en-US|access-date=2019-10-08}}</ref> to "[[OpenMP]]-style" threads<ref>{{Cite web|url=https://discourse.julialang.org/t/julia-and-concurrency/25556/2|title=Julia and Concurrency|date=2019-06-24|website=JuliaLang|language=en-US|access-date=2019-09-22}}</ref>), and [[foreign function interface|direct calling]] of [[C (programming language)|C]] and [[Fortran]] libraries without [[adapter pattern#gluecode|glue code]]. Julia uses a [[just-in-time compilation|just-in-time]] (JIT) compiler that is referred to as "just-[[ahead-of-time compilation|ahead-of-time]]" (JAOT) in the Julia community, as Julia compiles all code (by default) to [[machine code]] before running it.<ref>{{cite web |last1=Fischer |first1=Keno |last2=Nash |first2=Jameson |title=Growing a Compiler - Getting to Machine Learning from a General Purpose Compiler - JuliaHub |url=https://juliahub.com/blog/2019/02/growing-a-compiler/ |access-date=2022-11-16 |website=juliahub.com}}</ref><ref>{{cite web |title=Creating a sysimage |url=https://julialang.github.io/PackageCompiler.jl/dev/devdocs/sysimages_part_1/ |website=PackageCompiler Documentation}}</ref>

Julia is [[garbage collection (computer science)|garbage-collected]],<ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/6_XvoLBzN60 |title=Suspending Garbage Collection for Performance...good idea or bad idea? |website=Groups.google.com |access-date=2017-05-31}}</ref> uses [[eager evaluation]], and includes efficient libraries for [[floating-point arithmetic|floating-point]] calculations, [[linear algebra]], [[random number generation]], and [[regular expression]] matching. Many libraries are available, including some (e.g., for [[fast Fourier transform]]s) that were previously bundled with Julia and are now separate.<ref>now available with <code>using [[FFTW]]</code> in current versions (That dependency, is one of many which, was moved out of the standard library to a package because it is GPL licensed, and thus is not included in Julia 1.0 by default.) {{Cite web|url=https://github.com/JuliaLang/julia/pull/21956|title=Remove the FFTW bindings from Base by ararslan · Pull Request #21956 · JuliaLang/julia|website=GitHub|language=en|access-date=2018-03-01}}</ref>

Several development tools support coding in Julia, such as [[integrated development environment]]s (e.g. for Microsoft's [[Visual Studio Code]], an [[plug-in (computing)|extension]] is available<ref>{{Cite web |title=Julia for Visual Studio Code |url=https://www.julia-vscode.org/ |access-date=2022-07-17 |website=www.julia-vscode.org}}</ref> providing debugging and [[lint (software)|linting]] support); with integrated tools, e.g. a [[profiling (computer programming)|profiler]] (and flame graph support available<ref>{{cite web|last=Holy|first=Tim|title=GitHub - timholy/ProfileView.jl: Visualization of Julia profiling data.|website=[[GitHub]]|date=2019-09-13|url=https://github.com/timholy/ProfileView.jl|access-date=2019-09-22}}</ref><ref>{{cite web|last=Gregg|first=Brendan|title=GitHub - brendangregg/FlameGraph: Stack trace visualizer.|website=[[GitHub]]|date=2019-09-20|url=https://github.com/brendangregg/FlameGraph|access-date=2019-09-22}}</ref> for the built-in one), debugger,<ref>{{Cite web|url=https://julialang.org/blog/2019/03/debuggers|title=A Julia interpreter and debugger|website=julialang.org|access-date=2019-04-10}}</ref> and the Rebugger.jl package "supports [[interactive programming|repeated-execution debugging]]"{{Efn|<!--quote= --> [With Rebugger.jl] it is possible to:
* test different modifications to the code or arguments without exiting "debug mode" or saving the file
* run the same chosen block of code repeatedly without needing to repeat "setup" work placing nested method in the original call stack.<ref name="Rebugger">{{Cite web|url=https://discourse.julialang.org/t/ann-rebugger-interactive-debugging-for-julia-0-7-1-0/13843|title=[ANN] Rebugger: interactive debugging for Julia 0.7/1.0|quote=<!--Better in the "Efn" footnote above?-->
|date=2018-08-21|website=JuliaLang|language=en|access-date=2019-04-10}}</ref>}} and more.<ref>{{Cite web|url=https://timholy.github.io/Rebugger.jl/dev/|title=Home · Rebugger.jl|website=timholy.github.io|access-date=2019-04-10}}</ref>

Julia works with other languages, calling C has special support, <!-- ccall keyword, and later a @ccall macro, also extra support for in packages --> and with use of extra packages, e.g. for working with Python<!-- PythonCall.jl bidirecional in-process-->, R<!-- R mode-->, Rust, C++, SQL and to work with or even to compile to JavaScript.

Julia can be compiled to binary [[executable]]s using a package <!-- PackageCompiler.jl mentioned in main text --> for it supporting all Julia features. Small binary executables can also be made using a different package <!-- StaticCompiler.jl --> but then the Julia [[runtime (program lifecycle phase)|runtime]] isn't included in the executable, e.g. down to <!-- "~8.4 kb" --> 9&nbsp;KB (then without e.g. the garbage collector since it's part of Julia's runtime, i.e. with similar limited capabilities to the [[C (programming)|C]] language), for computers or even microcontrollers with 2&nbsp;KB of RAM. By default, Julia code depends on the Julia runtime to support all Julia features, e.g. threading, but some (non-idiomatic, to smaller or larger degree) Julia code can be compiled to small executables (with limited Julia capabilities). In both cases no [[source code]] needs to be distributed.

==History==
Work on Julia was started in 2009, by [[Jeff Bezanson (programmer)|Jeff Bezanson]], [[Stefan Karpinski]], [[Viral B. Shah]], and [[Alan Edelman]], who set out to create a free language that was both high-level and fast. On 14 February 2012, the team launched a website with a blog post explaining the language's mission.<ref>{{cite web|authors=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman|title=Why We Created Julia|url=https://julialang.org/blog/2012/02/why-we-created-julia|website=JuliaLang.org|access-date=5 June 2017}}</ref> In an interview with ''[[InfoWorld]]'' in April 2012, Karpinski said of the name "Julia": "There's no good reason, really. It just seemed like a pretty name."<ref name="infoworld" /> Bezanson said he chose the name on the recommendation of a friend,<ref>{{cite web |last1=Torre |first1=Charles |title=Stefan Karpinski and Jeff Bezanson on Julia |url=https://channel9.msdn.com/Blogs/Charles/Stefan-Karpinski-and-Jeff-Bezanson-Julia-Programming-Language |website=Channel 9 |publisher=MSDN |access-date=4 December 2018}}</ref> then years later wrote:

{{blockquote|Maybe julia stands for "[[Jeff Bezanson (programmer)|Jeff]]'s [[MLisp|uncommon lisp]] is automated"?<ref>{{cite web |last1=Bezanson |first1=Jeff |title=CAS Benchmarks |url=https://discourse.julialang.org/t/cas-benchmarks-symbolics-jl-and-maxima/58359/17 |website=discourse.julialang.org |date=2 April 2021 |publisher=Julia |access-date=2 April 2021}}</ref>}}

In the 10 years since the 2012 launch of pre-1.0 Julia, the community has grown. The Julia package ecosystem has over 11.8 million lines of code (including docs and tests).<ref>{{Cite web |title=Newsletter August 2021 - Julia Computing Completes $24 Million Series A Fundraise and Former Snowflake CEO Bob Muglia Joins Julia Computing Board of Directors - JuliaHub |url=https://juliahub.com/blog/2021/08/newsletter-august/ |access-date=2022-11-16 |website=juliahub.com}}</ref> The JuliaCon [[academic conference]] for Julia users and developers has been held annually since 2014 with JuliaCon2020 welcoming over 28,900 unique viewers,<ref>{{Cite web|date=2020-08-11|title=JuliaCon 2020 Wrap-up|url=https://julialang.org/blog/2020/08/juliacon-2020-wrapup/#outcomes|access-date=2020-12-20|website=julialang.org}}</ref> and then JuliaCon2021 breaking all previous records (with more than 300 JuliaCon2021 presentations available for free on YouTube, up from 162 the year before), and 43,000 unique viewers during the conference.<ref>{{Cite web|title=JuliaCon 2021 Highlights|url=https://julialang.org/blog/2021/08/juliacon-highlights/|access-date=2021-09-06|website=julialang.org|language=en}}</ref>

Three of the Julia co-creators are the recipients of the 2019 [[J. H. Wilkinson Prize for Numerical Software|James H. Wilkinson Prize for Numerical Software]] (awarded every four years) "for the creation of Julia, an innovative environment for the creation of high-performance tools that enable the analysis and solution of computational science problems."<ref>{{Cite web |title=Julia language co-creators win James H. Wilkinson Prize for Numerical Software |url=https://news.mit.edu/2018/julia-language-co-creators-win-james-wilkinson-prize-numerical-software-1226 |access-date=2019-01-22 |website=MIT News}}</ref> Also, Alan Edelman, professor of applied mathematics at MIT, has been selected to receive the 2019 IEEE Computer Society [[Sidney Fernbach Award]] "for outstanding breakthroughs in high-performance computing, linear algebra, and computational science and for contributions to the Julia programming language."<ref>{{Cite press release |url=https://www.computer.org/press-room/2019-news/2019-ieee-fernbach-award-edelman |title=Alan Edelman of MIT Recognized with Prestigious 2019 IEEE Computer Society Sidney Fernbach Award {{!}} IEEE Computer Society |language=en-US |date=1 October 2019 |access-date=2019-10-09}}</ref>

<!-- Version 0.3 was released in August 2014, version 0.6 in June 2017.<ref>{{cite web|url=https://julialang.org/blog/2017/06/julia-0.6-release|title=Julia 0.6 Release Announcement}}</ref> -->
Both Julia 0.7<ref>{{Cite web|url=https://discourse.julialang.org/t/what-is-julia-0-7-how-does-it-relate-to-1-0/9994|title=What is Julia 0.7? How does it relate to 1.0?|website=JuliaLang|date=26 March 2018|language=en|access-date=2018-10-17}}</ref> and version 1.0 were released on 8 August 2018. Work on Julia 0.7 was a "huge undertaking" (e.g., because of an "entirely new optimizer"), and some changes were made to semantics, e.g. the [[iteration]] interface was simplified;<ref>{{Cite web|url=https://julialang.org/blog/2018/07/iterators-in-julia-0.7 |title=Writing Iterators in Julia 0.7 |first=Eric |last=Davies |website=julialang.org |access-date=2018-08-05}}</ref> and the syntax changed a little (with the syntax now stable, and same for 1.x and 0.7).

Julia 1.1 was released in January 2019 with a new "exception stack" feature.

Julia 1.2 was released in August 2019 with some built-in support for web browsers.<ref>{{Cite web|title=Sys.isjsvm([os])|date=2019-08-20|url=https://github.com/JuliaLang/julia/blob/75c10e435b2b9c947422ad38fa0b020595d3f747/base/sysinfo.jl#L401|quote=Predicate for testing if Julia is running in a JavaScript VM (JSVM), including e.g. a WebAssembly JavaScript embedding in a web browser.|publisher=The Julia Language|access-date=2019-08-20}}</ref>

Julia 1.3 added composable multi-threaded parallelism and a binary artifacts system for Julia packages.<ref>{{Cite web|url=https://julialang.org/blog/2019/11/artifacts|title=The Julia Language|first1=Jeff|last1=Bezanson|first2=Stefan|last2=Karpinski|first3=Viral|last3=Shah|first4=Alan|last4=Edelman|website=julialang.org|access-date=2019-12-13}}</ref>

Julia 1.4 added syntax for generic array indexing to handle e.g. [[zero-based numbering#Usage in programming languages|0-based]] arrays.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/33946|title=support a[begin] for a[firstindex(a)] by stevengj · Pull Request #33946 · JuliaLang/julia|website=GitHub|language=en|access-date=2020-04-07}}</ref> The memory model was also changed.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/32448|title=For structs with all isbits or isbitsunion fields, allow them to be s<!--…-->tored inline in arrays <!--by quinnj--> · Pull Request #32448 · JuliaLang/julia|author=quinnj|quote=I still keep running into problems that this causes internally because it was a breaking change that changes assumptions made by some users and inference/codegen.|website=GitHub|language=en|access-date=2020-04-07}}</ref>

Julia 1.5 released in August 2020 added [[record and replay debugging]] support,<ref>{{Cite web|title=Coming in Julia 1.5: Time Traveling (Linux) Bug Reporting|url=https://julialang.org/blog/2020/05/rr/|date=2 May 2020 |first=Keno |last=Fischer|website=julialang.org|language=en|quote=Overhead for recording of single threaded processes is generally below 2x, most often between 2% and 50% (lower for purely numerical calculations, higher for workloads that interact with the OS). Recording multiple threads or processes that share memory (as opposed to using kernel-based message passing) is harder. [..] As expected, the threads test is the worst offender with about 600% overhead. |access-date=2020-05-05}}</ref> for Mozilla's [[rr (debugging)|rr]] tool. <!-- It can be used manually in earlier versions, without Julia's help. --> The release changed the behavior in the [[Read–eval–print loop|REPL]] (soft scope) to the one used in [[Project Jupyter|Jupyter]], but fully compatible with non-REPL code. Most of the [[Thread (computing)|thread API]] was marked as stable, and with this release "arbitrary immutable objects—regardless of whether they have fields that reference mutable objects or not—can now be stack allocated",<ref>{{Cite web|authors=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman |display-authors=etal |title=The Julia Language|url=https://julialang.org/blog/2020/08/julia-1.5-highlights/|access-date=2020-08-14|quote=There are some size-based limits to which structs can be stack allocated, but they are unlikely to be exceeded in practice.|website=julialang.org|language=en}}</ref> reducing heap allocations, e.g. <code>views</code> are no longer allocating. <!-- "± and ∓ are now unary operators as well, like + or -"--> Julia 1.5 targeted so-called "time-to-first-plot" performance, in general, the speed of compilation itself (as opposed to performance of the generated code), and adds tools for developers to improve package loading.<ref>{{Cite web|authors=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman |display-authors=etal |title=The Julia Language|url=https://julialang.org/blog/2020/08/invalidations/|access-date=2020-09-16|website=julialang.org|language=en}}</ref>

Julia 1.6 was the largest release since 1.0, faster on many fronts, e.g. introduced parallel precompilation and faster loading of packages, in some cases "50x speedup in load times for large trees of binary artifacts".<ref>{{Cite web|authors=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman |display-authors=etal|title=Julia 1.6 Highlights|url=https://julialang.org/blog/2021/03/julia-1.6-highlights/|access-date=2021-03-26|website=julialang.org|language=en}}</ref>

As of version 1.7 Julia development is back to [[release early, release often|time-based releases]].<ref>{{Cite web|title=Upgrade to OpenBLAS 0.3.13 · Pull Request #39216 · JuliaLang/julia|url=https://github.com/JuliaLang/julia/pull/39216#issuecomment-816285199|access-date=2021-04-26|website=GitHub|language=en|quote=Given that 1.7 is not too far away (timed releases going forward)}}</ref>

Julia 1.7.0 was released in November 2021, with many changes, e.g. a new faster [[random number generation|random-number generator]].

Julia 1.7.3 was released on 25 May 2022, fixing some issues, including at least one security update.<ref>{{Cite web |title=[Zlib_jll] Update to v1.2.12+3 by giordano · Pull Request #44810 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/44810 |access-date=2022-05-25 |website=GitHub |language=en}}</ref>

Julia 1.8 has been released (and 1.8.1 and 1.8.2 as followup on 29 September 2022, both fixing bugs and invalidations, thus compiling faster), with improvements for distributing Julia programs without source code, <!-- --strip-metadata and --strip-ir --> and compiler speedup, in some cases by 25%,<ref>{{Cite web |title=compiler: speed up bootstrapping time by 25% by aviatesk · Pull Request #41794 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/41794 |access-date=2022-03-03 |website=GitHub |language=en |quote=the bootstrapping took about 80 seconds previously, but on this PR the time is reduced to about 60 seconds.}}</ref> <!-- "Bootstrapping time has been improved by about 25%" --> and more controllable [[inline expansion|inlining]] (i.e. now also allowing applying <code>@inline</code> at the call site, not just on the function itself) and Julia 1.9 is the next milestone, it and the milestones for 1.10, 1.11, 1.12 and 2.0 currently have no set due dates.<ref>{{Cite web |title=Milestones - JuliaLang/julia |url=https://github.com/JuliaLang/julia/milestones |access-date=2022-08-27 |website=GitHub |language=en}}</ref><ref>{{Cite web|date=2021-09-14|title=The future of Julia, 1.6, 1.7-rc1, 1.8, 1.9, 1.10 and 2.0 and LTS|url=https://discourse.julialang.org/t/the-future-of-julia-1-6-1-7-rc1-1-8-1-9-1-10-and-2-0-and-lts/68143/4|access-date=2022-01-17|website=JuliaLang|quote=I suspect at some point 1.x work will slow down a bit and we'll get some more capacity to stop and think about 2.0 kinds of changes, but that time just hasn't happened yet.|language=en}}</ref>

===JuliaCon===
Since 2014,<ref>{{Cite web|url=https://juliacon.org/2014/|title=JuliaCon 2014|website=juliacon.org|access-date=2021-06-20}}</ref> the Julia Community has hosted an annual Julia Conference focused on developers and users. The first JuliaCon took place in Chicago and kickstarted the annual occurrence of the conference. Since 2014, the conference has taken place across a number of locations including MIT<ref>{{Cite web|url=https://news.mit.edu/2016/juliacon-draws-global-users-of-dynamic-programming-language-0718|title=JuliaCon 2016 at MIT|website=mit.edu|access-date=2021-06-20}}</ref> and the University of Maryland, Baltimore.<ref>{{Cite web|url=https://technical.ly/baltimore/2019/07/23/juliacon-provides-the-stage-for-a-week-of-programming-talks-and-a-new-baltimore-company/|title=JuliaCon 2019 at UMB|website=technical.ly|date=23 July 2019|access-date=2021-06-20}}</ref> The event audience has grown from a few dozen people to over 28,900 unique attendees<ref>{{Cite web|url=https://julialang.org/blog/2020/08/juliacon-2020-wrapup/#outcomes|title=JuliaCon 2020 wrap up|website=julialang.org|access-date=2021-06-20}}</ref> during JuliaCon 2020, which took place virtually. JuliaCon 2021 also took place virtually<ref>{{Cite web|url=https://juliacon.org/2021/|title=JuliaCon 2021|website=Juliacon.org|access-date=2021-06-20}}</ref> with keynote addresses from professors [[William Kahan]] (the primary architect of the [[IEEE 754-1985|IEEE 754]] floating-point standard, which his keynote is about, that virtually all CPUs use and languages, including Julia),<ref>{{Cite web |title=JuliaCon 2021 Highlights |url=https://julialang.org/blog/2021/08/juliacon-highlights/ |access-date=2022-03-03 |website=julialang.org |language=en |quote=This year's JuliaCon was the biggest and best ever, with more than 300 presentations available for free on YouTube, more than 20,000 registrations, and more than 43,000 unique YouTube viewers during the conference, up from 162 presentations, 10,000 registrations, and 28,900 unique YouTube viewers during last year's conference.}}</ref> and Jan Vitek,<ref>{{Cite web|url=http://janvitek.org|title=Jan Vitek Homepage|website=janvitek.org|access-date=2021-06-20}}</ref> Xiaoye [[Sherry Li]], and Soumith Chintala (co-creator of [[PyTorch]]).<ref>{{Cite web|url=https://soumith.ch|title=Soumith Chintala Homepage|website=soumith.ch|access-date=2021-06-20}}</ref> JuliaCon grew to 43,000 unique attendees and more than 300 presentations (still freely accessible, plus for older years). JuliaCon 2022 will also be virtual held between July 27 and July 29, 2022, for the first time in several languages, not just in English.

===Sponsors===
The Julia language became a [[NumFOCUS]] fiscally sponsored project in 2014 in an effort to ensure the project's long-term sustainability.<ref>{{Cite web|url=https://numfocus.org/project/julia|title=Julia: NumFOCUS Sponsored Project since 2014|website=numfocus.org|access-date=2020-09-29}}</ref> Jeremy Kepner at [[MIT Lincoln Laboratory]] was the founding sponsor of the Julia project in its early days. In addition, funds from the [[Gordon and Betty Moore Foundation]], the [[Alfred P. Sloan Foundation]], [[Intel]], and agencies such as [[National Science Foundation|NSF]], [[DARPA]], [[National Institutes of Health|NIH]], [[NASA]], and [[Federal Aviation Administration|FAA]] have been essential to the development of Julia.<ref>{{Cite web|url=https://julialang.org/research/|title=The Julia Language|website=julialang.org|access-date=2019-09-22}}</ref> [[Mozilla]], the maker of Firefox web browser, with its research grants for H1 2019, sponsored "a member of the official Julia team" for the project "Bringing Julia to the Browser",<ref>{{Cite web|url=https://www.zdnet.com/article/mozilla-is-funding-a-way-to-support-julia-in-firefox/|title=Mozilla is funding a way to support Julia in Firefox|last=Cimpanu|first=Catalin|website=ZDNet|language=en|access-date=2019-09-22}}</ref> meaning to Firefox <!-- "and the general browser environment--> and other web browsers.<ref>{{Cite web|url=https://alpha.iodide.io/notebooks/225/|title=Julia in Iodide|website=alpha.iodide.io|access-date=2019-09-22}}</ref><ref>{{Cite web|url=https://iodide-project.github.io/docs/language_plugins/|title=Language plugins - Iodide Documentation|website=iodide-project.github.io|access-date=2019-09-22}}</ref><ref>{{Cite web|url=https://mozilla-research.forms.fm/mozilla-research-grants-2019h1/forms/6510|title=Mozilla Research Grants 2019H1|website=Mozilla|language=en|quote=running language interpreters in WebAssembly. To further increase access to leading data science tools, we're looking for someone to port R or Julia to WebAssembly and to attempt to provide a level 3 language plugin for Iodide: automatic conversion of data basic types between R/Julia and Javascript, and the ability to share class instances between R/Julia and Javascript.|access-date=2019-09-22}}</ref><ref>{{Cite web|title=Literate scientific computing and communication for the web: iodide-project/iodide|date=2019-09-20|url=https://github.com/iodide-project/iodide|publisher=iodide|quote=We envision a future workflow that allows you to do your data munging in Python, fit a quick model in R or JAGS, solve some differential equations in Julia, and then display your results with a live interactive d3+JavaScript visualization&nbsp;... and all that within within a single, portable, sharable, and hackable file.|access-date=2019-09-22}}</ref> The Julia language is also supported by individual donors on GitHub.<ref>{{Cite web|url=https://github.com/sponsors/JuliaLang|title=Sponsor the Julia Language|website=github.com|access-date=2021-06-05}}</ref>

===Julia company===
JuliaHub, Inc. was founded in 2015 as Julia Computing, Inc. by [[Viral B. Shah]], Deepak Vinchhi, [[Alan Edelman]], [[Jeff Bezanson]], [[Stefan Karpinski]] and [[Keno Fischer]].<ref>{{Cite web|url=https://juliacomputing.com/about-us|title=About Us – Julia Computing|website=juliacomputing.com|access-date=2017-09-12}}</ref><ref>{{Cite web |title=About Us - JuliaHub |url=https://juliahub.com/company/about-us/ |access-date=2022-11-16 |website=juliahub.com}}</ref>

In June 2017, Julia Computing raised US$4.6{{nbsp}}million in seed funding from [[General Catalyst]] and [[Founder Collective]],<ref>{{cite web|url=https://juliacomputing.com/communication/2017/06/19/seed-funding.html|title=Julia Computing Raises $4.6M in Seed Funding|archive-url=https://web.archive.org/web/20190510040656/https://juliacomputing.com/communication/2017/06/19/seed-funding.html|archive-date=2019-05-10}}</ref> the same month was "granted $910,000 by the [[Alfred P. Sloan Foundation]] to support [[open-source software|open-source]] Julia development, including $160,000 to promote diversity in the Julia community",<ref>{{Cite web|date=2017-06-26|title=Julia Computing Awarded $910,000 Grant by Alfred P. Sloan Foundation, Including $160,000 for STEM Diversity|url=https://juliacomputing.com/media/2017/06/26/sloan-grant.html|access-date=2020-07-28|website=juliacomputing.com}}</ref> and in December 2019 the company got $1.1{{nbsp}}million funding from the US government to "develop a neural component [[machine learning]] tool to reduce the total energy consumption of heating, ventilation, and air conditioning (HVAC) systems in buildings".<ref>{{Cite web|title=DIFFERENTIATE—Design Intelligence Fostering Formidable Energy Reduction (and) Enabling Novel Totally Impactful Advanced Technology Enhancements|url=https://arpa-e.energy.gov/sites/default/files/documents/files/DIFFERENTIATE_Project_Descriptions_FINAL.pdf}}</ref> In July 2021, Julia Computing announced they raised a $24 million [[Series A round]] led by Dorilton Ventures,<ref>{{Cite news|title=Julia Computing raises $24 mln in funding round led by Dorilton Ventures|newspaper=Reuters|date=19 July 2021|url=https://www.reuters.com/technology/julia-computing-raises-24-mln-funding-round-led-by-dorilton-ventures-2021-07-19/}}</ref> which also owns {{nowrap|[[Formula 1]]}} team [[Williams Grand Prix Engineering|Williams Racing]], that partnered with Julia Computing. Williams' Commercial Director said: "Investing in companies building best-in-class cloud technology is a strategic focus for Dorilton and Julia's versatile platform, with revolutionary capabilities in simulation and modelling, is hugely relevant to our business. We look forward to embedding Julia Computing in the world's most technologically advanced sport".<ref>{{Cite press release|title=Williams welcomes Julia Computing as Dorilton Ventures partner|url=https://www.williamsf1.com/news/2021/partners/williams-welcomes-julia-computing|access-date=2021-09-02|website=www.williamsf1.com|language=en}}</ref>

==Language features==
Julia is a [[general-purpose programming language]],<ref>{{cite web
  | title = The Julia Language
  | type  = official website
  | url   = https://julialang.org/
  | quote = General Purpose [..] Julia lets you write UIs, statically compile your code, or even deploy it on a webserver.
}}</ref> while also originally designed for numerical/technical computing.
It is also useful for low-level [[system programming|systems programming]],<ref name="LowLevelSystemsProgrammingInJulia">{{cite web |url=http://juliacon.org/2018/talks_workshops/42/
|archive-url=https://web.archive.org/web/20181105083419/http://juliacon.org/2018/talks_workshops/42/
|archive-date=5 November 2018
|first=Todd |last=Green
|title=Low-Level Systems Programming in High-Level Julia
|date=10 August 2018
|access-date=5 November 2018
}}</ref> as a [[specification language]],<ref name="spec">{{cite web|last=Moss|first=Robert|date=26 June 2015|title=Using Julia as a Specification Language for the Next-Generation Airborne Collision Avoidance System|url=https://juliacon.org/2015/images/juliacon2015_moss_v3.pdf|url-status=live|archive-url=https://web.archive.org/web/20150701182804/http://juliacon.org/talks.html|archive-date=1 July 2015|access-date=29 June 2015|quote=[[Airborne collision avoidance system]]}}</ref> High-level Synthesis (HLS) tool (for hardware, e.g. [[field-programmable gate array|FPGA]]s),<ref name = "HLS/FPGA">{{Cite arXiv|title=High-level Synthesis using the Julia Language |eprint=2201.11522 |quote=We present a prototype Julia HLS tool, written in Julia, that transforms Julia code to VHDL.|last1=Biggs |first1=Benjamin |last2=McInerney |first2=Ian |last3=Kerrigan |first3=Eric C. |last4=Constantinides |first4=George A. |year=2022 |class=cs.SE }}</ref> and for web programming<ref>{{Cite press release|work=plotly|date=2020-10-26|title=Announcing Dash for Julia|url=https://medium.com/plotly/announcing-dash-for-julia-f017c90c6ef1|access-date=2021-09-02|language=en}}</ref> at both server<ref>{{Cite web|url=https://medium.com/@richardanaya/how-to-create-a-multi-threaded-http-server-in-julia-ca12dca09c35|title=How to create a multi-threaded HTTP server in Julia|last=Anaya|first=Richard|date=2019-04-28|website=Medium|language=en|access-date=2019-07-25|quote=In summary, even though Julia lacks a multi-threaded server solution currently out of box, we can easily take advantage of its process distribution features and a highly popular load balancing tech to get full CPU utilization for HTTP handling.}}</ref><ref>{{Cite web|last=Anthoff|first=David|title=Node.js installation for julia|website=[[GitHub]]|date=2019-06-01|url=https://github.com/davidanthoff/NodeJS.jl|access-date=2019-07-25}}</ref><!--<ref name="node-js">{{cite web|url=https://node-julia.readme.io/|title=Getting Started with Node Julia · Node Julia|website=Node-julia.readme.io|access-date=2017-05-31}}</ref> --> and client<ref name="JSExpr"/><ref name="WebAssembly"/> side.

The main features of the language are:<!-- this list was on the official website, it's since, here, been slightly modified, to clarify some of it -->

* Multiple dispatch: providing ability to define function behavior across combinations of argument types
* [[Dynamic type]] system: types for documentation, optimization, and dispatch
* Performance approaching that of [[type system|statically-typed]] languages like C
* A built-in [[package manager]]
* [[Lisp (programming language)|Lisp]]-like macros and other [[metaprogramming]] facilities
* Call [[C (programming language)|C]] functions directly without wrappers or special [[application programming interface|APIs]]
* Ability to interface with other languages, e.g. PythonCall.jl allows calling to or from Python (also possible with PyCall.jl{{Efn|For calling [[Python 3]] (the older default to call Python 2, is also still supported)<ref>{{cite web |url=https://github.com/JuliaPy/PyCall.jl |title=PyCall.jl |work=stevengj |date=7 November 2021 |publisher=github.com}}</ref><ref>{{cite newsgroup |url=https://groups.google.com/forum/#!topic/julia-users/lDM7-YXT2LU |title=Using PyCall in julia on Ubuntu with python3 |work=julia-users at Google Groups|quote=to import modules (e.g., python3-numpy)}}</ref> <!--([[PyPy]] and e.g. [[PHP]] was/is supported<ref name="Polyglot">{{cite web|url=https://gitlab.com/wavexx/Polyglot.jl|title=wavexx / Polyglot.jl|website=GitLab|language=en|access-date=2019-07-25}}</ref> for Julia 0.5 (PyPy should work; supported by python-bond that Polyglot.jl is based on); [[Jython]] support is not confirmed, but since JavaCall.jl allows calling Java (and thus Scala) I assume also Jython.)--> and calling in the other direction, from Python to Julia, is also supported with ''pyjulia''.<ref>{{cite web |url=https://github.com/JuliaPy/pyjulia |title=python interface to julia|website=[[GitHub]]|date=6 November 2021}}</ref>
<!--
It is not like Polyglot.jl does not support this for older Julia (and also interesting project to support other languages, e.g., PHP), but it has not been upgraded for Julia 1.0: Even calling [[recursive]]ly (back and forth) between these languages is possible, without (or with) using ''Polyglot.jl'',<ref name="Polyglot"/> that supports additional languages to Python. 
-->

}}), R with RCall.jl, and Java/Scala with JavaCall.jl
* [[shell (computing)|shell]]-like abilities to manage other processes
* Designed for [[parallel computing|parallel]] and [[distributed computing]]
* [[Coroutine]]s: lightweight [[green thread|''green'' threading]]
* User-defined types are as compact as built-ins
* Automatic generation of code for different argument types
* Extensible conversions and promotions for numeric and other types
* Support for [[Unicode]], including but not limited to [[UTF-8]]
<!-- |source=JuliaLang.org}} Only part missing it the MIT part, that is better explained elsewhere.-->

Multiple dispatch (also termed [[multimethod]]s in Lisp) is a [[generalization]] of [[single dispatch]]{{snd}} the [[polymorphism (computer science)|polymorphic mechanism]] used in common [[object-oriented programming]] (OOP) languages, such as [[Python (programming language)|Python]], [[C++]], [[Java (programming language)|Java]], [[JavaScript]], and [[Smalltalk]]{{snd}} that uses [[inheritance (object-oriented programming)|inheritance]]. In Julia, all concrete types are [[subtyping|subtypes]] of abstract types, directly or indirectly subtypes of the <code>Any</code> type, which is the top of the type hierarchy. Concrete types can not themselves be subtyped the way they can in other languages; composition is used instead (see also [[Inheritance (object-oriented programming)#Inheritance vs subtyping|inheritance vs subtyping]]).

By default, the Julia runtime must be pre-installed as user-provided source code is run. Alternatively, a standalone [[executable]] that needs no Julia source code can be built with e.g. ''PackageCompiler.jl''.<ref>{{cite web|title=GitHub - JuliaLang/PackageCompiler.jl: Compile your Julia Package.|date=2019-02-14|url=https://github.com/JuliaLang/PackageCompiler.jl|publisher=The Julia Language|access-date=2019-02-15}}</ref>

Julia's [[Macro (computer science)#Syntactic macros|syntactic macros]] (used for [[metaprogramming]]), like Lisp macros, are more powerful than [[Macro (computer science)#Text-substitution macros|text-substitution macros]] used in the [[preprocessor]] of some other languages such as C, because they work at the level of [[abstract syntax tree]]s (ASTs). Julia's macro system is [[hygienic macro|hygienic]], but also supports deliberate capture when desired (like for [[anaphoric macro]]s) using the <code>esc</code> construct.

Julia draws inspiration from various dialects of Lisp<!-- Karpinski: "In short, I would describe it as a Lisp with Matlab-like syntax" https://www.reddit.com/r/programming/comments/pv3k9/why_we_created_julia_a_new_programming_language/ -->, including [[Scheme (programming language)|Scheme]] and [[Common Lisp]], and it shares many features with [[Dylan (programming language)|Dylan]], also a multiple-dispatch-oriented dynamic language (which features an [[ALGOL]]-like [[free-form language|free-form]] [[infix notation|infix]] syntax rather than a Lisp-like prefix syntax, while in Julia "everything"<ref name="Learn Julia in Y">{{cite web|url=https://learnxinyminutes.com/docs/julia/ |title=Learn Julia in Y Minutes |website=Learnxinyminutes.com |access-date=2017-05-31}}</ref> is an [[expression (computer science)|expression]]), and with [[Fortress (programming language)|Fortress]], another numerical programming language (which features multiple dispatch and a sophisticated parametric type system). While [[Common Lisp Object System]] (CLOS) adds multiple dispatch to Common Lisp, not all functions are generic functions.

In Julia, Dylan, and Fortress, extensibility is the default, and the system's built-in functions are all generic and extensible. In Dylan, multiple dispatch is as fundamental as it is in Julia: all user-defined functions and even basic built-in operations like <code>+</code> are generic. Dylan's type system, however, does not fully support parametric types, which are more typical of the [[Generational list of programming languages#ML based|ML lineage of languages]]. By default, CLOS does not allow for dispatch on Common Lisp's parametric types; such extended dispatch semantics can only be added as an extension through the [[Common Lisp Object System#Metaobject Protocol|CLOS Metaobject Protocol]]. By convergent design, Fortress also features multiple dispatch on parametric types; unlike Julia, however, Fortress is statically rather than dynamically typed, with separate compiling and executing phases. The language features are summarized in the following table:

{| class="wikitable"
|-
! [[Programming language|Language]] !! [[Type system]] !! [[Generic function]]s !! [[Parametric polymorphism|Parametric types]]
|-
| Julia || Dynamic || Default || {{Yes}}
|-
| [[Common Lisp]] || Dynamic || Opt-in || {{Yes2|Yes (but no dispatch)}}
|-
| [[Dylan (programming language)|Dylan]] || Dynamic || Default || {{Partial}} (no dispatch)
|-
| [[Fortress (programming language)|Fortress]] || Static || Default || {{Yes}}
|}

An example of the extensibility of Julia, the Unitful.jl package adds support for physical [[unit of measurement|units of measurement]] to the language.

==Interaction==
The Julia official distribution includes an interactive command-line [[read–eval–print loop]] (REPL),<ref>{{Cite web|url=https://docs.julialang.org/en/v1/stdlib/REPL/|title=The Julia REPL · The Julia Language|website=docs.julialang.org|access-date=2019-09-22}}</ref> with a searchable history, [[command-line completion|tab completion]], and dedicated help and [[shell (computing)|shell]] modes,<ref>{{Cite web|url=https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL|title=Introducing Julia/The REPL - Wikibooks, open books for an open world|website=en.wikibooks.org|quote=you can install the Julia package OhMyREPL.jl [..] which lets you customize the REPL's appearance and behaviour|access-date=2019-09-22}}</ref> which can be used to experiment and test code quickly.<ref>{{Cite web|url=https://docs.julialang.org/en/v1/manual/getting-started/|title=Getting Started · The Julia Language|website=docs.julialang.org|language=en|access-date=2018-08-15}}</ref> The following fragment represents a sample session example where strings are concatenated automatically by println:<ref>See also: {{URL|https://docs.julialang.org/en/v1/manual/strings/}} for string interpolation and the <code>string(greet, ", ", whom, ".\n")</code> example for preferred ways to concatenate strings. <!--While the <code>+</code> operator is not used for string concatenation, it could easily be defined to do so.--> Julia has the println and print functions, but also a @printf macro (i.e., not in function form) to eliminate run-time overhead of formatting (unlike the same function in C).</ref>

<syntaxhighlight lang="jlcon">
julia> p(x) = 2x^2 + 1; f(x, y) = 1 + 2p(x)y
julia> println("Hello world!", " I'm on cloud ", f(0, 4), " as Julia supports recognizable syntax!")
Hello world! I'm on cloud 9 as Julia supports recognizable syntax!
</syntaxhighlight>

The REPL gives user access to the system shell and to help mode, by pressing <code>;</code> or <code>?</code> after the prompt (preceding each command), respectively. It also keeps the history of commands, including between sessions.<ref>{{cite web|title=Julia Documentation|url=https://docs.julialang.org|website=JuliaLang.org|access-date=18 November 2014}}</ref> Code can be tested inside Julia's interactive session or saved into a file with a <code>.jl</code> extension and run from the command line by typing:<ref name="Learn Julia in Y"/>

<syntaxhighlight lang="console">
 $ julia <filename>
</syntaxhighlight>

Julia uses [[UTF-8]], e.g. for source code, meaning also allowing as an option common math symbols for many operators, such as ∈ for the <code>in</code> operator, typable with <code>\in</code> then pressing {{keypress|TAB}} (i.e. uses [[LaTeX]] codes, or also possible by simply copy-pasting, e.g. {{not a typo|√ and ∛}} possible for [[square root|sqrt]] and [[cube root|cbrt]] functions). Julia has support for Unicode 14.0 (from 2021, and 1.9-DEV supports the latest Unicode 15.0<ref>{{Cite web |title=support Unicode 15 via utf8proc 2.8 by stevengj · Pull Request #47392 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/47392 |access-date=2022-11-03 |website=GitHub |language=en}}</ref>), for the languages of the world, even for source code, e.g. variable names (while not using English isn't recommended for code for others to read e.g. package names).<ref>{{Cite web |date=2022-10-21 |title=support Unicode 14.0.0 (via utf8proc 2.7.0) |url=https://github.com/JuliaLang/julia/pull/43443 |url-status=live |access-date=2022-11-03 |website=Github |language=en}}</ref>

Julia is supported by [[Project Jupyter|Jupyter]], an online interactive "notebooks" environment,<ref>{{cite web |url=https://jupyter.org/ |title=Project Jupyter}}</ref> and [https://github.com/fonsp/Pluto.jl Pluto.jl], a "'''''reactive''''' notebook" (where notebooks are saved as pure Julia files), a possible replacement for the former kind.<ref>{{Cite web|last=Boudreau|first=Emmett|date=2020-10-16|title=Could Pluto Be A Real Jupyter Replacement?|url=https://towardsdatascience.com/could-pluto-be-a-real-jupyter-replacement-6574bfb40cc6|access-date=2020-12-08|website=Medium|language=en}}</ref>

The REPL can be extended with additional modes, and has been with packages, e.g. with an [[SQL]] mode,<ref>{{Cite web |first=Chris |last=Foster |title=SQLREPL.jl |website=[[GitHub]] |date=2022-04-04 |url=https://github.com/c42f/SQLREPL.jl |access-date=2022-09-27}}</ref> for database access, and RCall.jl adds an {{nowrap|R mode}}, to work with the [[R (programming language)|R language]].<ref>{{Cite web |title=Getting Started · RCall.jl |url=https://juliainterop.github.io/RCall.jl/latest/gettingstarted.html#Several-Ways-to-use-RCall-1 |access-date=2022-09-27 |website=juliainterop.github.io}}</ref>

===Use with other languages===
Julia is in practice [[interoperability|interoperable]] with other languages (e.g. majority of top 10–20 languages in popular use). Julia's <syntaxhighlight lang="julia" inline>ccall</syntaxhighlight> keyword is used to call C-exported or Fortran shared library functions individually, and packages are available to allow calling other languages e.g. Python, R, MATLAB, C# (and other .NET languages with DotNET.jl), JavaScript, Java (and other JVM languages, such as Scala with JavaCall.jl).<ref>{{Cite web|date=2020-06-02|title=Julia and Spark, Better Together|url=https://juliacomputing.com/blog/2020/06/02/julia-spark.html|access-date=2020-07-14|website=juliacomputing.com}}</ref> And packages for other languages allow to call to Julia, e.g. from Python, R, [[Rust (programming language)|Rust]], or Ruby, such as with pyjulia and PythonCall.jl/juliacall for Python and a different JuliaCall package for R. Julia has also been used for hardware, i.e. to compile to [[VHDL]], as a High-level Synthesis (HLS) tool (for e.g. [[field-programmable gate array|FPGA]]s).<ref name = "HLS/FPGA" />

Julia has packages supporting markup languages such as [[HTML]] (and also for [[HTTP]]), [[XML]], [[JSON]] and [[BSON]], and for [[database]]s (such as PostgreSQL,<ref>{{Cite web |title=Home · LibPQ.jl |url=https://invenia.github.io/LibPQ.jl/stable/ |access-date=2022-11-08 |website=invenia.github.io}}</ref> Mongo,<ref name="FunSQL" /> Oracle, including for [[TimesTen]],<ref>{{Cite web |last=Hood |first=Doug |date=21 October 2022 |title=Using Julia with Oracle Databases |url=https://blogs.oracle.com/timesten/post/using-julia-with-oracle-database}}</ref> MySQL, SQLite, Microsoft SQL Server,<ref name="FunSQL">{{Cite web |title=Home · FunSQL.jl |url=https://docs.juliahub.com/FunSQL/HGzDG/0.9.2/ |access-date=2022-11-08 |website=docs.juliahub.com}}</ref> Amazon Redshift, Vertica, ODBC) and web use in general.<ref>{{Cite web |title=Genie Builder - Visual Studio Marketplace |url=https://marketplace.visualstudio.com/items?itemName=GenieBuilder.geniebuilder |access-date=2022-11-08 |website=marketplace.visualstudio.com |language=en-us}}</ref><ref>{{Cite web |date=2022-02-01 |title=How to Build Your First Web App in Julia with Genie.jl 🧞‍♂️ |url=https://www.freecodecamp.org/news/how-to-build-web-apps-in-julia/ |access-date=2022-11-08 |website=freeCodeCamp.org |language=en}}</ref>

==Package system==
Julia has a built-in [[package manager]] and includes a default registry system.<ref>{{Cite web|url=https://github.com/JuliaRegistries/General|title=JuliaRegistries / General|website=[[GitHub]]|access-date=2020-04-30}}</ref> Packages are most often distributed as source code hosted on [[GitHub]], though alternatives can also be used just as well. Packages can also be installed as binaries, using artifacts.<ref>{{Cite web|url=https://julialang.github.io/Pkg.jl/dev/artifacts/|title=Pkg.jl - Artifacts|access-date=2020-06-04}}</ref> Julia's package manager is used to query and compile packages, as well as managing environments. Federated package registries are supported, allowing registries other than the official to be added locally.<ref>{{Cite web|url=https://julialang.github.io/Pkg.jl/v1/registries/|title=Pkg.jl - Registries|access-date=2020-04-30}}</ref>

==Implementation==
Julia's core is implemented in Julia and [[C (programming language)|C]],<!--C99, except for 0.4 needing C11 because of static asserts--> together with [[C++]] for the [[LLVM]] dependency. The code parsing and code-lowering are implemented in FemtoLisp, a [[Scheme (programming language)|Scheme]] dialect<ref name="JeffBezanson 2019">{{cite web | first=Jeff | last=Bezanson | title=JeffBezanson/femtolisp | website=GitHub | date=6 June 2019 | url=https://github.com/JeffBezanson/femtolisp | access-date=16 June 2019}}</ref> (that parser can however be switched out at runtime, with the pure-Julia package ''JuliaSyntax.jl'',<ref>{{Cite web |title=JuliaSyntax |date=2022-08-28 |url=https://github.com/JuliaLang/JuliaSyntax.jl |publisher=The Julia Programming Language |access-date=2022-08-28}}</ref> a drop-in, faster replacement, usually, and it "greatly improves parser error messages in various cases",<ref>{{Cite web |title=Enable JuliaSyntax.jl as an alternative Julia parser by c42f · Pull Request #46372 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/pull/46372 |access-date=2022-08-28 |website=GitHub |language=en}}</ref> thus it's being considered as an addition to Julia, first as a non-default option in 1.10.0, but can already be used in older versions). A non-default parser package ''Parser.jl'' (for e.g. much faster [[floating-point number]] parsing on Windows<ref>{{Cite web |title=issue with parsing float in MS Windows · Issue #45612 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/issues/45612 |access-date=2022-08-28 |website=GitHub |language=en |quote=The parse function performs poorly in MS Windows, and using simple threading escalates the problem significantly.}}</ref>) is available, already used indirectly by some packages, but is also being considered for inclusion into Julia.<ref>{{Cite web |title=Move Parsers.jl to base · Issue #45301 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/issues/45301 |access-date=2022-08-28 |website=GitHub |language=en}}</ref> The LLVM compiler infrastructure project is used as the [[Compiler#Back end|back end]] for generation of [[64-bit computing|64-bit]] or [[32-bit]] optimized [[machine code]] depending on the platform Julia runs on. With some exceptions (e.g., [[Perl Compatible Regular Expressions|PCRE]], which is being considered for removal in Julia 2.0;<ref>{{Cite web |title=move Regex into a stdlib · Issue #38300 · JuliaLang/julia |url=https://github.com/JuliaLang/julia/issues/38300 |access-date=2022-08-28 |website=GitHub |language=en}}</ref> Julia already has alternative [[regular expression|regex]] libraries, e.g. ''RE2.jl'' for Google's re2, ''StrRegex.jl'' and ''ReadableRegex.jl''), the [[standard library]] is implemented in Julia. A very notable aspect of Julia's implementation is its speed, which is often within a factor of two relative to fully optimized C code (and thus often an order of magnitude faster than Python or [[R (programming language)|R]]).<ref>[https://julialang.org/assets/blog/nyhackr.pd Julia: A Fast Dynamic Language for Technical Computing – slides]</ref><ref>
{{cite arXiv |last1=Bezanson |first1=Jeff |last2=Karpinski |first2=Stefan |last3=Shah |first3=Viral B. |last4=Edelman |first4=Alan |date=2012-09-23 |title=Julia: A Fast Dynamic Language for Technical Computing |class=cs.PL |eprint=1209.5145 }}</ref><!--
A dead link replaced by above, I believe same content <ref name="Julia-TR">{{cite web
  | title      = Julia: A Fast Dynamic Language for Technical Computing
  | url        = https://julialang.org/images/julia-dynamic-2012-tr.pdf
  | year       = 2012
  }}</ref>--><ref>{{cite web
  | title      = How To Make Python Run As Fast As Julia
  | website    = [[IBM]]
  | url        = https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Meets_Julia_Micro_Performance?lang=en
  | year       = 2015
  }}</ref><ref>{{cite web
  | title      = Basic Comparison of Python, Julia, R, Matlab and IDL
  | url        = https://modelingguru.nasa.gov/docs/DOC-2625
  | archive-url = https://web.archive.org/web/20171127104803/https://modelingguru.nasa.gov/docs/DOC-2625
  | url-status = dead
  | archive-date = 2017-11-27
  | year       = 2015
  }}</ref> Development of Julia began in 2009 and an [[open-source software|open-source]] version was publicized in February 2012.<ref name="announcement">{{cite web
  | title      = Why We Created Julia
  | date       = February 2012
  | website    = Julia website
  | url        = https://julialang.org/blog/2012/02/why-we-created-julia
  | access-date = 7 February 2013
  }}</ref><ref>{{cite web
  | last       = Gibbs
  | first      = Mark
  | title      = Pure and Julia are cool languages worth checking out
  | url        = https://www.networkworld.com/columnists/2013/010913-gearhead.html
  | type       = column
  | work       = Network World
  | date       = 9 January 2013
  | access-date = 7 February 2013
}}</ref>

===Current and future platforms===
Julia has tier 1 [[macOS]] support, meaning for Intel-based Macs, but also for the new [[Apple M1]]-based Macs, by either ''running in [[Rosetta 2]] emulation'',<ref name="Apple Silicon">{{Cite web |date=2022-05-25 |title=Julia v1.7.3 has been released |url=https://discourse.julialang.org/t/julia-v1-7-3-has-been-released/81683 |access-date=2022-05-26 |website=JuliaLang |language=en}}</ref><ref>{{Cite web|title=Darwin/ARM64 tracking issue · Issue #36617 · JuliaLang/julia|url=https://github.com/JuliaLang/julia/issues/36617|access-date=2020-12-08|website=GitHub|language=en}}</ref> or, while then, with tier 2 native (non-Rosetta) support with Julia 1.8 (unlike the older LTS version of Julia which only has tier 3 (experimental) support; [[Windows 10|Windows on ARM]] has no official support yet). The work on that support (i.e. without emulation) is mostly done, and many programs work with Julia 1.8.0. Julia was prior to 1.8.0 claimed to work<ref>{{Cite web|last=Carlton|first=Sam|title=ThatGuySam/doesitarm|website=[[GitHub]] |date=2020-12-08|url=https://github.com/ThatGuySam/doesitarm|access-date=2020-12-08}}</ref> "ok" on M1 Macs (at reduced performance) through the (automatic) use of Rosetta 2 (that needs to emulate Julia<!-- it usually compiles a program in install, but since Julia generates naive code at runtime, Rosetta needs to emulate it with its JIT capability, and it's slower.-->).

Since Julia uses JIT,<!-- Viral states "Julia no longer uses the MCJIT in LLVM" so this link is probably misleading:
<ref>{{cite web |url=https://github.com/JuliaLang/julia/pull/5208
|title=Support MCJIT
|website=Github.com
|access-date=26 May 2015
}}</ref> --> Julia generates native machine code directly, before a function is first run (i.e. a different approach than compiling to [[bytecode]], that you distribute by default, to be run on a [[virtual machine]] (VM), as with e.g. Java/[[Java virtual machine|JVM]]; then translated from the bytecode while running, as done by [[Dalvik (software)|Dalvik]] on older versions of Android).

Julia has four support tiers.<ref>{{cite web|url=https://julialang.org/downloads/#support-tiers|title=Julia Downloads|website=julialang.org|access-date=2019-05-17}}</ref> All [[IA-32]] processors completely implementing the [[P6 (microarchitecture)|i686]] subarchitecture are supported and all 64-bit [[x86-64]] (aka [[amd64]]), i.e. all less than about a decade old are supported. [[ARMv8]] ([[AArch64]]) processors are supported on second tier, and ARMv7 and ARMv6 (AArch32) are supported with some caveats (lower tier) for Julia 1.0.x and also had official executables for later versions, while 32-bit ARM support was later downgraded to tier 3 (however, unofficial binaries are available for Julia 1.5.1<ref>{{Cite web|date=2019-01-23|title=Bring Julia code to embedded hardware (ARM)|url=https://discourse.julialang.org/t/bring-julia-code-to-embedded-hardware-arm/19979|access-date=2021-03-30|website=JuliaLang|language=en}}</ref>).<ref>{{cite web |title=julia/arm.md |date=2021-10-07 |url=https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/build/arm.md |publisher=The Julia Language|quote=A list of known issues for ARM is available.|access-date=2022-05-15}}</ref> Hundreds of packages are [[general-purpose computing on graphics processing units|GPU-accellerated]]:<ref>{{Cite web |title=JuliaGPU |url=https://juliagpu.org/ |access-date=2022-11-16 |website=juliagpu.org |quote=Almost 300 packages rely directly or indirectly on Julia's GPU capabilities.}}</ref> [[CUDA]] (i.e. Nvidia GPUs; implementing [[Parallel Thread Execution|PTX]]) has tier 1 support, with the help of an external package. There are also additionally packages supporting other accelerators, such as Google's [[tensor processing unit|TPU]]s,<ref>{{cite web|title=Julia on TPUs|date=2019-11-26|url=https://github.com/JuliaTPU/XLA.jl|publisher=JuliaTPU|access-date=2019-11-29}}</ref> and some Intel (integrated) GPUs, through [[oneAPI (compute acceleration)|oneAPI.jl]],<ref>{{Cite web|title=Introducing: oneAPI.jl ⋅ JuliaGPU|url=https://juliagpu.org/post/2020-11-05-oneapi_0.1/|access-date=2021-09-06|website=juliagpu.org}}</ref> and AMD's GPUs have support with e.g. [[OpenCL]]; and experimental support for the AMD [[ROCm]] stack.<ref>{{Cite web|url=https://juliagpu.org/rocm/|title=AMD ROCm · JuliaGPU|website=juliagpu.org|access-date=2020-04-20}}</ref> Julia's downloads page provides [[executable]]s (and source) for all the officially supported platforms.

On some platforms, Julia may need to be compiled from source code (e.g., the original [[Raspberry Pi]]), with specific build options, which has been done and unofficial pre-built binaries (and build instructions) are available.<ref>{{Cite web|title=Build Julia for RaspberryPi Zero|url=https://gist.github.com/terasakisatoshi/3f8a55391b1fc22a5db4a43da8d92c98|access-date=2020-08-14|website=Gist|language=en}}</ref><ref>{{Cite web|title=JuliaBerry: Julia on the Raspberry Pi|url=https://juliaberry.github.io/|access-date=2020-08-14|website=juliaberry.github.io}}</ref> Julia has been built <!--on the following ARMv8 devices:

* [https://www.nvidia.com/object/embedded-systems-dev-kits-modules.html nVidia Jetson TX1 & TX2];
* [https://www.apm.com/products/data-center/x-gene-family/x-gene/ X-Gene 1];
* [https://softiron.com/products/overdrive-3000/ Overdrive 3000];
* [https://www.cavium.com/ThunderX_ARM_Processors.html Cavium ThunderX]-->
for several ARM platforms, from small Raspberry Pis to (recent) top-1 supercomputer [[Fugaku (supercomputer)|Fugaku]]'s ARM-based [[Fujitsu A64FX|A64FX]].<ref>{{Cite web |last=Giordano |first=Mosè |title=Julia on Fugaku (2022-07-23) |website=[[GitHub]] |date=2022-09-29 |url=https://github.com/giordano/julia-on-fugaku |access-date=2022-11-08}}</ref> PowerPC (64-bit) has tier 3 support, meaning it "may or may not build".
<!--
 Support for ARM, [[AArch64]], and [[Power Architecture|POWER8]] (little-endian) has been added recently as of 0.5.1 is available too.<ref>{{cite web|url=https://github.com/JuliaLang/julia/blob/v0.5.2/README.md |title=julia/README.md at v0.5.2 · JuliaLang/julia · GitHub |website=Github.com |date=2017-05-03 |access-date=2017-05-31}}</ref>

and in 0.5.x:

"work in progress" text dropped with (not yet backported (possibly the text, only docs left behind?) to 0.6.x): https://github.com/JuliaLang/julia/commit/dcffef03594779402bb5c2666fbcf24b4438adba#diff-8b8b297c5626992d7377a6bbb3aadceb

"only supports ARMv7" text dropped on master (may apply on older, meaning possibly only for ARMv6?:

"[[Nightly build]]s are available for ARMv7-A. [..] Note that OpenBLAS only supports ARMv7. For older ARM variants, using the reference BLAS may be the simplest thing to do. [..] Note: These [Raspberry Pi] chips use ARMv6, which is not well supported at the moment. However it is possible to get a working Julia build. [e.g., supported] [[Tegra#Tegra P1|nVidia Jetson TX2]] [with] CUDA functionality"<ref>{{cite web|publisher=JuliaLang |url=https://github.com/JuliaLang/julia/blob/v0.6.2/README.arm.md |title=julia/README.arm.md at v0.5.2 · JuliaLang/julia · GitHub |website=Github.com |access-date=2017-05-31}}</ref>

The [[Raspberry Pi]] support also includes limited support for [[Raspberry Pi]] 1 (since it has [[ARMv6]]),<ref>{{cite web |url=https://github.com/JuliaLang/julia/issues/10488
|title=Cross-compiling for ARMv6
|quote=I believe #10917 should fix this. The CPU used there <code>arm1176jzf-s</code>. Please reopen if it does not.
|access-date=16 May 2015}}
</ref><ref>
{{cite web |url=https://github.com/JuliaLang/julia/issues/10235
|title=ARM build failing during bootstrap on Raspberry Pi 2
|quote=I can confirm (FINALLY) that it works on the Raspberry Pi 2 [..] I guess we can announce alpha support for arm in 0.4 as well. |access-date=16 May 2015}}</ref>

-->
Julia is now supported in [[Raspbian]]<ref>{{cite web |url=https://julialang.org/blog/2017/05/raspberry-pi-julia |title=Julia available in Raspbian on the Raspberry Pi |quote=Julia works on all the Pi variants, we recommend using the Pi 3.}}</ref> while support is better for newer Pis, e.g., those with ARMv7 or newer; the Julia support is promoted by the [[Raspberry Pi Foundation]].<ref>{{cite web |url=https://www.raspberrypi.org/blog/julia-language-raspberry-pi/ |title=Julia language for Raspberry Pi |work=[[Raspberry Pi Foundation]]|date=12 May 2017 }}</ref>

There is also support for web browsers/[[JavaScript]] through JSExpr.jl;<ref name="JSExpr">{{Cite web|title=Translate Julia to JavaScript |date=2019-07-07|url=https://github.com/JuliaGizmos/JSExpr.jl|publisher=JuliaGizmos|access-date=2019-07-25}}</ref> and the alternative language of web browsers, [[WebAssembly]], has minimal support<ref name="WebAssembly">{{Cite web|last=Fischer|first=Keno|title=Running julia on wasm|website=[[GitHub]]|date=2019-07-22|url=https://github.com/Keno/julia-wasm|access-date=2019-07-25}}</ref> for several upcoming external Julia projects.
<!--
Julia supports [[64-bit computing|64-bit]] [[ARM architecture|ARM]] and [[PowerPC]] and "fully supports [[ARMv8]] ([[AArch64]]) processors, and supports ARMv7 and ARMv6 (AArch32) with some caveats"<ref>{{cite web|url=https://github.com/JuliaLang/julia/blob/master/README.arm.md|title=julia/README.arm.md at master|publisher=JuliaLang/julia|website=Github.com|archive-url=https://web.archive.org/web/20170330223636/https://github.com/JuliaLang/julia/blob/master/README.arm.md|archive-date=2017-03-30}}</ref><ref>{{cite web|url=https://github.com/JuliaLang/julia/issues/10791#issuecomment-91735439|title=AArch64 build fails surprisingly close to the end (building sys0.o)}}</ref> and [[PowerPC]] being worked on, with almost no open specific issues,<ref>{{cite web|url=https://github.com/JuliaLang/julia/labels/Power|title=Issues - label:Power|publisher=JuliaLang/julia|website=Github.com}}</ref><ref>{{cite web |url=https://groups.google.com/forum/#!topic/julia-dev/BYVCyUlNR8c |title=Porting Julia to PowerPC |quote=Wow, the latest git allows me to build to completion. |access-date=9 May 2015}}</ref> with [[executable|binaries]] available for [[POWER7]] ("due to some small support from [[IBM]]") and [[POWER8]], that are expected to have official beta support as of 0.5 (at least for non-parallel support).<ref>{{cite web |url=https://groups.google.com/forum/#!topic/julia-users/xB0k7XMBNqM |title=IBM Power port |quote=I am hoping we can have beta support from the 0.5 release onwards for sequential julia. We were able to do this work due to some small support from IBM.}}</ref>
-->
<!--
Support for [[GNU/kFreeBSD]] and [[GNU Hurd]] is being worked on (in JuliaLang's [[C mathematical functions#libm|openlibm]] dependency project).<ref>{{cite web|url=https://github.com/JuliaLang/openlibm/pull/129 |title=Fix building tests on GNU/kFreeBSD and GNU/Hurd by ginggs · Pull Request #129 · JuliaLang/openlibm |website=Github.com |access-date=2017-05-31}}</ref>
Yes, openlibm, is not Julia, but is a dependency of it-->
<!--
An unofficial Julia-lite,<ref>{{cite web|url=https://github.com/ScottPJones/julia/tree/spj/lite|title=ScottPJones/julia at spj/lite|website=Github.com}}</ref> a trimmed down fork (by now outdated), is a available. Officially Julia has been dropping dependencies and features from the standard library, to make GPL-free (one left), so it's also the official plan.
-->
Julia can compile to ARM; thus, in theory, [[Android app]]s can be made with the [[Android software development#Android NDK|NDK]], but for now Julia has been made to run under [[Android (operating system)|Android]] only indirectly, ''i.e.'' with a Ubuntu [[chroot]] on Android.<ref>{{Cite web|url=https://discourse.julialang.org/t/using-julia-on-android/8086/7|title=Using Julia on Android?|date=2019-09-27|website=JuliaLang|language=en-US|access-date=2019-10-02}}</ref>

While Julia requires an [[operating system]] by default, and has no official support to run without or on [[embedded system]] platforms like [[Arduino]], Julia code has still been run, with some limitations, on a baremetal 16&nbsp;[[Hertz#Computers|MHz]] [[8-bit computing|8-bit]] [[AVR microcontrollers|AVR-microcontroller]] Arduino with 2&nbsp;KB RAM (plus 32&nbsp;KB of flash memory).<ref>{{Cite web |title=Running Julia baremetal on an Arduino |url=https://seelengrab.github.io/articles/Running%20Julia%20baremetal%20on%20an%20Arduino/ |access-date=2022-05-24 |website=seelengrab.github.io}}</ref>

== Adoption ==
Julia has been adopted by many universities including [[MIT]], [[Stanford University|Stanford]], and [[UC Berkeley]]. Large private firms across many sectors have adopted the language including [[Amazon (company)|Amazon]], [[IBM]], [[BlackRock]], [[JP Morgan]], [[ASML Holding|ASML]], and many of the largest pharma companies. Julia has also been used in government agencies like [[NASA]] and the [[Federal Aviation Administration|FAA]] as well as every US national energy laboratory.<ref>{{Cite web |title='Why We Created Julia' Turns Ten Years Old - JuliaHub |url=https://juliahub.com/company/media/2022/02/julia-turns-ten-years-old/ |access-date=2022-11-16 |website=juliahub.com}}</ref><ref>{{Cite web |title=Newsletter January 2022 - Julia Growth Statistics - Julia Computing |url=https://juliacomputing.com/blog/2022/01/newsletter-january/ |access-date=2022-01-26 |website=juliacomputing.com |language=en}}</ref>

=== Scientific computing ===
* The Climate Modeling Alliance selected Julia for implementing their next generation global climate model to provide insight into the effects and challenges of climate change.<ref name="Julia_Nvidia">{{Cite press release |title=Julia Computing Brings Support for NVIDIA GPU Computing on Arm Powered Servers - JuliaHub |url=https://juliahub.com/blog/2019/12/nvidia-ngc-arm/ |access-date=2022-11-16 |website=juliahub.com}}</ref>
* NASA models spacecraft separation dynamics,<ref>{{Citation |title=Modeling Spacecraft Separation Dynamics in Julia - Jonathan Diegelman |url=https://www.youtube.com/watch?v=tQpqsmwlfY0 |language=en |access-date=2021-09-06}}</ref><ref>{{Citation |title=Circuitscape/Circuitscape.jl |date=2020-02-25 |url=https://github.com/Circuitscape/Circuitscape.jl |publisher=Circuitscape |access-date=2020-05-26}}</ref><ref>{{Cite web |title=Conservation through Coding: 5 Questions with Viral Shah {{!}} Science Mission Directorate |url=https://science.nasa.gov/earth-science/applied-sciences/making-space-for-earth/5-questions-with-viral-shah |access-date=2020-05-26 |website=science.nasa.gov}}</ref> analyzes ([[TRAPPIST]]) [[exoplanet]] datasets<ref>{{Cite web |title=Julia in the Wild - Julia Data Science |url=https://juliadatascience.io/julia_wild |access-date=2022-09-12 |website=juliadatascience.io}}</ref><ref>{{Cite web |title=Seven Rocky TRAPPIST-1 Planets May Be Made of Similar Stuff |url=https://exoplanets.nasa.gov/news/1669/seven-rocky-trappist-1-planets-may-be-made-of-similar-stuff/ |access-date=2022-10-06 |website=Exoplanet Exploration: Planets Beyond our Solar System}}</ref> and [[cosmic microwave background]] data from the [[Big Bang]].<ref>{{Citation |title=Julia in Astronomy & Astrophysics Research {{!}} Eric B. Ford {{!}} JuliaCon 2022 |url=https://www.youtube.com/watch?v=vj1uzilanQI |language=en |access-date=2022-10-06}}</ref>
* The Brazilian [[National Institute for Space Research|INPE]] plans space missions and simulates [[satellite]]s in Julia.<ref>{{Citation |title=JuliaSpace/SatelliteToolbox.jl |date=2020-05-20 |url=https://github.com/JuliaSpace/SatelliteToolbox.jl |publisher=JuliaSpace |access-date=2020-05-26}}</ref>
* [[CERN]] uses Julia<ref>{{Cite web |date=27 September 2021 |title=Julia for HEP Mini-workshop |url=https://indico.cern.ch/event/1074269/ |access-date=2022-08-23 |website=indico.cern.c h |quote=Julia and the first observation of Ω<sup>-</sup>_b → Ξ<sup>+</sup>_c K<sup>-</sup> π<sup>-</sup>}}</ref><ref>{{Cite web |last=Mikhasenko |first=Misha |date=2022-07-29 |title=ThreeBodyDecay |url=https://github.com/mmikhasenko/ThreeBodyDecay.jl |access-date=2022-08-23 |website=[[GitHub]]}}</ref><ref>{{Cite web |last=Mikhasenko |first=Misha |date=July 2021 |title=Julia for QCD spectroscopy |url=https://indico.cern.ch/event/1074269/contributions/4539610/attachments/2317472/3945345/spectroscopy_mmikhasenko.pdf |access-date=2022-08-23 |website=indico.cern.ch |quote=Summary: Julia is ready to be used in physics HEP analysis}}.</ref> for the [[Large Hadron Collider]] ([[LHCb experiment]]).<ref>{{Cite web |date=2022-08-19 |title=JuliaHEP/UnROOT.jl |url=https://github.com/JuliaHEP/UnROOT.jl |access-date=2022-08-23 |publisher=JuliaHEP}}</ref><ref>{{Cite web |title=Julia · Search · GitLab |url=https://gitlab.cern.ch/search?search=Julia&nav_source=navbar&project_id=741&group_id=635&scope=commits&repository_ref=master |access-date=2022-08-23 |website=GitLab |language=en}}</ref><ref>{{Cite web |title=Commits · master · sft / lcgcmake · GitLab |url=https://gitlab.cern.ch/sft/lcgcmake/-/commits/master/cmake/toolchain/heptools-dev-base.cmake |access-date=2022-08-23 |website=GitLab |language=en |quote=bump julia version to 1.7.3}}</ref>

=== Other notable uses ===
* The [[Federal Reserve Bank of New York]] created economic models of the United States with Julia in 2015 (ported from [[MATLAB]]), and its later version 1.3 includes estimating [[COVID-19]] shocks in 2021.<ref>{{Cite web |title=Release v1.3.0 · FRBNY-DSGE/DSGE.jl |url=https://github.com/FRBNY-DSGE/DSGE.jl/releases/tag/v1.3.0 |access-date=2022-01-03 |website=[[GitHub]] |language=en |quote=New subspecs of Model1002 for estimating the DSGE with COVID-19 shocks}}</ref>
* [[BlackRock]] analyzes [[time series]] using Julia.<ref name=":0">{{Cite web |last=D'Cunha |first=Suparna Dutt |date=2017-09-20 |title=How A New Programming Language Created By Four Scientists Now Used By The World's Biggest Companies |url=https://www.forbes.com/sites/suparnadutt/2017/09/20/this-startup-created-a-new-programming-language-now-used-by-the-worlds-biggest-companies/ |url-status=live |archive-url=https://web.archive.org/web/20221001082708/https://www.forbes.com/sites/suparnadutt/2017/09/20/this-startup-created-a-new-programming-language-now-used-by-the-worlds-biggest-companies/?sh=2c98522a7de2 |archive-date=2022-10-01 |access-date=2022-10-01 |website=Forbes |language=en}}</ref>
* [[Aviva]] calculates risk for insurance with Julia.<ref name=":0" />
* [[Mitre Corporation]] produced verification software for published election results using Julia.<ref>{{Cite web |title=Julia for Election Security |url=https://forem.julialang.org/ramsdell/julia-for-election-security-4gh |access-date=2022-09-27 |website=Julia Community 🟣 |language=en}}</ref>

==See also==
* [[Comparison of numerical-analysis software]]
* [[Comparison of statistical packages]]
* [[Differentiable programming]]
* [[JuMP]] {{ndash}} an algebraic modeling language for mathematical optimization embedded in Julia

==Notes==
{{Notelist|80em}}

==References==
{{Reflist|25em}}

==Further reading==
* {{cite book|last=Nagar|first=Sandeep|year=2017|title=Beginning Julia Programming: For Engineers and Scientists|publisher=Springer |isbn=9781484231715 |url=https://books.google.com/books?id=KmRADwAAQBAJ&pg=PR1 }}
* {{cite journal|last1=Bezanson|first1=J|last2=Edelman|first2=A|last3=Karpinski|first3=S|last4=Shah|first4=V. B|year=2017|title=Julia: A fresh approach to numerical computing|journal=SIAM Review |volume=59 |issue=1 |pages=65–98 |doi=10.1137/141000671 |arxiv=1411.1607 |citeseerx=10.1.1.760.8894|s2cid=13026838}}
* {{cite book|last=Joshi|first=Anshul|year=2016|title=Julia for Data Science － Explore the world of data science from scratch with Julia by your side|publisher=Packt |isbn=9781783553860 |url=https://books.google.com/books?id=Bn9cDgAAQBAJ&pg=PP2}}
* Tobin A Driscoll and Richard J. Braun (Aug. 2022). "Fundamentals of Numerical Computation: Julia Edition". SIAM. {{ISBN|978-1-611977-00-4}}.
* C. T. Kelley (2022). "Solving Nonlinear Equations with Iterative Methods: Solvers and Examples in Julia", SIAM. {{ISBN|978-1-611977-26-4}}.
* {{cite book|last=Kalicharan|first=Noel|year=2021|title=Julia - Bit by Bit|series=Undergraduate Topics in Computer Science |publisher=Springer |doi=10.1007/978-3-030-73936-2 |isbn=978-3-030-73936-2 |s2cid=235917112 |url=https://link.springer.com/book/10.1007/978-3-030-73936-2 }}

==External links==
{{Wikibooks|Introducing Julia}}
* {{Official website|https://julialang.org}}
* {{GitHub|JuliaLang/julia}}

{{Programming languages}}
{{FOSS}}
{{Numerical analysis software}}
{{Mathematical optimization software}}
{{Statistical software}}
{{Differentiable computing}}
{{Authority control}}

[[Category:2012 software]]
[[Category:Array programming languages]]
[[Category:Articles with example Julia code]]
[[Category:Notebook interface]]
[[Category:Cross-platform software]]
[[Category:Data mining and machine learning software]]
[[Category:Data-centric programming languages]]
[[Category:Dynamically typed programming languages]]
[[Category:Free compilers and interpreters]]<!-- note there's also a Julia interpreter (not on by default); besides FemtoLisp.-->
[[Category:Free computer libraries]]
[[Category:Free data analysis software]]
[[Category:Free data visualization software]]
[[Category:Free software programmed in C]]
[[Category:Free software programmed in Julia]] <!-- Julia is written, mostly, in Julia. -->
[[Category:Free software projects]]
[[Category:Free statistical software]]
[[Category:Functional languages]]
[[Category:High-level programming languages]]
[[Category:Homoiconic programming languages]]
[[Category:Lisp programming language family]]
[[Category:Multi-paradigm programming languages]]<!-- ok? Mostly only using the main paradigm multiple-dispatch, but Julia enables using more, e.g. implementing class-based OO-->
[[Category:Numerical analysis software for Linux]]
[[Category:Numerical analysis software for macOS]]
[[Category:Numerical analysis software for Windows]]
[[Category:Numerical libraries]] <!--for Julia's standard library: seems ok, as e.g. part of (and all planned) C's libm has been rewritten in Julia-->
[[Category:Numerical linear algebra]]
[[Category:Numerical programming languages]]
[[Category:Object-oriented programming languages]]
[[Category:Parallel computing]]
[[Category:Procedural programming languages]]
[[Category:Programming languages]]
[[Category:Programming languages created in 2012]]
<!-- [[Category:Scripting languages]] ? -->
[[Category:Software using the MIT license]]
[[Category:Statistical programming languages]]
[[Category:Text-oriented programming languages]]
[[Category:Programming languages supporting units of measure]]