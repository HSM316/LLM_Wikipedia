'''Shape context''' is a feature descriptor used in [[object recognition]]. [[Serge Belongie]] and [[Jitendra Malik]] proposed the term in their paper "Matching with Shape Contexts" in 2000.<ref name="shape_1">
{{cite conference
 |author1=S. Belongie  |author2=J. Malik
  |name-list-style=amp | title = Matching with Shape Contexts
 | book-title = IEEE Workshop on Contentbased Access of Image and Video Libraries (CBAIVL-2000)
 | year = 2000|doi=10.1109/IVL.2000.853834
 }}</ref>

==Theory==
The shape context is intended to be a way of describing shapes that allows for measuring shape similarity and the recovering of point correspondences.<ref name="shape_1"/> The basic idea is to pick ''n'' points on the contours of a shape. For each point ''p''<sub>''i''</sub> on the shape, consider the ''n''&nbsp;&minus;&nbsp;1 vectors obtained by connecting ''p''<sub>''i''</sub> to all other points. The set of all these vectors is a rich description of the shape localized at that point but is far too detailed. The key idea is that the distribution over relative positions is a robust, compact, and highly discriminative descriptor. So, for the point ''p''<sub>''i''</sub>, the coarse histogram of the relative coordinates of the remaining ''n''&nbsp;&minus;&nbsp;1 points,

: <math>h_i(k) = \#\{q \ne p_i  :  (q - p_i) \in \mbox{bin}(k)\}</math>

is defined to be the shape context of <math>p_i</math>. The bins are normally taken to be uniform in log-polar space. The fact that the shape context is a rich and discriminative descriptor can be seen in the figure below, in which the shape contexts of two different versions of the letter "A" are shown.

[[Image:shapecontext.jpg|800px]]

(a) and (b) are the sampled edge points of the two shapes. (c) is the diagram of the log-polar bins used to compute the shape context. (d) is the shape context for the point marked with a circle in (a), (e) is that for the point marked as a diamond in (b), and (f) is that for the triangle. As can be seen, since (d) and (e) are the shape contexts for two closely related points, they are quite similar, while the shape context in (f) is very different.

For a feature descriptor to be useful, it needs to have certain invariances. In particular it needs to be invariant to translation, scaling, small perturbations, and, depending on the application, rotation. Translational invariance comes naturally to shape context. Scale invariance is obtained by normalizing all radial distances by the mean distance <math>\alpha</math> between all the point pairs in the shape <ref name="shape_2">
{{cite journal
 |author1=S. Belongie |author2=J. Malik |author3=J. Puzicha  |name-list-style=amp | title = Shape Matching and Object Recognition Using Shape Contexts
 | url = http://www.eecs.berkeley.edu/Research/Projects/CS/vision/shape/belongie-pami02.pdf
 | journal = IEEE Transactions on Pattern Analysis and Machine Intelligence
 | volume = 24
 | issue = 4
 | date = April 2002
 | pages = 509–521
 | doi = 10.1109/34.993558|s2cid=129468 }}</ref><ref name="shape_3">
{{cite conference
 |author1=S. Belongie |author2=J. Malik |author3=J. Puzicha  |name-list-style=amp | title = Matching Shapes
 | url = http://www.eecs.berkeley.edu/Research/Projects/CS/vision/shape/belongie-iccv01.pdf
 | book-title = Eighth IEEE International Conference on Computer Vision (July 2001)
 |date=July 2001}}</ref> although the median distance can also be used.<ref name="shape_1"/><ref name="shape_4">
{{cite conference
 |author1=S. Belongie |author2=J. Malik |author3=J. Puzicha  |name-list-style=amp | title = Shape Context: A new descriptor for shape matching and object recognition
 | book-title = NIPS 2000
 | year = 2000|url=http://papers.nips.cc/paper/1913-shape-context-a-new-descriptor-for-shape-matching-and-object-recognition.pdf}}</ref> Shape contexts are empirically demonstrated to be robust to deformations, noise, and outliers<ref name="shape_4"/> using synthetic point set matching experiments.<ref>
{{cite conference
 |author1=H. Chui  |author2=A. Rangarajan
  |name-list-style=amp | title = A new algorithm for non-rigid point matching
 | book-title = CVPR
 | volume = 2
 | pages = 44–51
 |date=June 2000
 |doi=10.1109/CVPR.2000.854733
 }}</ref>

One can provide complete rotational invariance in shape contexts. One way is to measure angles at each point relative to the direction of the tangent at that point (since the points are chosen on edges). This results in a completely rotationally invariant descriptor. But of course this is not always desired since some local features lose their discriminative power if not measured relative to the same frame. Many applications in fact forbid rotational invariance e.g. distinguishing a "6" from a "9".

==Use in shape matching==
A complete system that uses shape contexts for shape matching consists of the following steps (which will be covered in more detail in the [[#Details of implementation|Details of Implementation]] section):

# Randomly select a set of points that lie on the edges of a known shape and another set of points on an unknown shape.
# Compute the shape context of each point found in step 1.
# Match each point from the known shape to a point on an unknown shape.  To minimize the cost of matching, first choose a transformation (e.g. [[affine transformation|affine]], [[thin plate spline]], etc.) that warps the edges of the known shape to the unknown (essentially aligning the two shapes).  Then select the point on the unknown shape that most closely corresponds to each warped point on the known shape.
# Calculate the "shape distance" between each pair of points on the two shapes.  Use a weighted sum of the shape context distance, the image appearance distance, and the bending energy (a measure of how much transformation is required to bring the two shapes into alignment).
# To identify the unknown shape, use a [[Nearest neighbor search|nearest-neighbor classifier]] to compare its shape distance to shape distances of known objects.

==Details of implementation==

===Step 1: Finding a list of points on shape edges===
The approach assumes that the shape of an object is essentially captured by a finite subset of the points on the internal or external contours on the object. These can be simply obtained using the [[Canny edge detector]] and picking a random set of points from the edges. Note that these points need not and in general do not correspond to key-points such as maxima of curvature or [[inflection point]]s. It is preferable to sample the shape with roughly uniform spacing, though it is not critical.<ref name="shape_2"/>

===Step 2: Computing the shape context===
This step is described in detail in the [[#Theory|Theory section]].

===Step 3: Computing the cost matrix===
Consider two points ''p'' and ''q'' that have normalized ''K''-bin histograms (i.e. shape contexts) ''g''(''k'') and ''h''(''k''). As shape contexts are distributions represented as histograms, it is natural to use the [[chi-squared statistic|''&chi;''<sup>2</sup> test statistic]] as the "shape context cost" of matching the two points:

: <math>C_S = \frac{1}{2}\sum_{k=1}^K \frac{[g(k) - h(k)]^2}{g(k) + h(k)}</math>

The values of this range from 0 to 1.<ref name="shape_1"/>
In addition to the shape context cost, an extra cost based on the appearance can be added. For instance, it could be a measure of tangent angle dissimilarity (particularly useful in digit recognition):

: <math>C_A = \frac{1}{2}\begin{Vmatrix}
 \dbinom{\cos(\theta_1)}{\sin(\theta_1)} - \dbinom{\cos(\theta_2)}{\sin(\theta_2)}
\end{Vmatrix}</math>

This is half the length of the chord in unit circle between the unit vectors with angles <math>\theta_1</math> and <math>\theta_2</math>. Its values also range from 0 to 1. Now the total cost of matching the two points could be a weighted-sum of the two costs:

: <math>C = (1 - \beta)C_S + \beta C_A\!\,</math>

Now for each point ''p''<sub>''i''</sub> on the first shape and a point ''q''<sub>''j''</sub> on the second shape, calculate the cost as described and call it ''C''<sub>''i'',''j''</sub>. This is the cost matrix.
<!--  Commented out because image was deleted: [[Image:Matching.png|thumb|200px|right|An example of the matching found between two handwritten "A"'s with costs defined only as the "shape context cost" between the two histograms]] -->

===Step 4: Finding the matching that minimizes total cost===
[[File:Matching example using the Shape Context descriptor.jpg|thumb|100px|right|Results of matching]]
Now, a one-to-one matching ''p''<sub>''i''</sub> that matches each point ''p''<sub>''i''</sub> on shape 1 and ''q''<sub>''j''</sub> on shape 2 that minimizes the total cost of matching,

: <math>H(\pi) = \sum_i C\left (p_i,q_{\pi (i)} \right )</math>

is needed. This can be done in <math>O(N^3)</math> time using the [[Hungarian method]], although there are more efficient algorithms.<ref>
{{cite journal
 |author1=R. Jonker  |author2=A. Volgenant
  |name-list-style=amp |title = A Shortest Augmenting Path Algorithm for Dense and Sparse Linear Assignment Problems
 |journal = Computing
 |volume = 38
 |pages = 325–340
 |year = 1987
 |doi = 10.1007/BF02278710
 |issue = 4|s2cid=7806079
 }}</ref>
To have robust handling of outliers, one can add "dummy" nodes that have a constant but reasonably large cost of matching to the cost matrix. This would cause the matching algorithm to match outliers to a "dummy" if there is no real match.

===Step 5: Modeling transformation===
Given the set of correspondences between a finite set of points on the two shapes, a transformation <math>T : \mathbb{R}^2 \to \mathbb{R}^2</math> can be estimated to map any point from one shape to the other. There are several choices for this transformation, described below.

====Affine====
The [[Affine transformation|affine model]] is a standard choice: <math>T(p) = Ap + o\!</math>. The [[least squares]] solution for the matrix <math>A</math> and the translational offset vector ''o'' is obtained by:

: <math>o = \frac{1}{n}\sum_{i=1}^n \left (p_i - q_{\pi(i)} \right ),
      A = (Q^+ P)^t</math>

Where <math>P = \begin{pmatrix}
             1 & p_{11} & p_{12} \\
             \vdots & \vdots & \vdots \\
             1 & p_{n1} & p_{n2}
\end{pmatrix} </math> with a similar expression for <math>Q\!</math>. <math>Q^+\!</math> is the [[Moore–Penrose pseudoinverse|pseudoinverse]] of <math>Q\!</math>.

====Thin plate spline====
The [[Thin plate spline|thin plate spline (TPS)]] model is the most widely used model for transformations when working with shape contexts. A 2D transformation can be separated into two TPS function to model a coordinate transform:

: <math> T(x,y) = \left (f_x(x,y),f_y(x,y)\right )</math>

where each of the ''ƒ''<sub>''x''</sub> and ''ƒ''<sub>''y''</sub> have  the form:

: <math> f(x,y) = a_1 + a_xx + a_yy + \sum_{i=1}^n\omega_iU\left (\begin{Vmatrix}
(x_i,y_i) - (x,y) \end{Vmatrix} \right ),</math>

and the kernel function <math>U(r)\!</math> is defined by <math>U(r) = r^2\log r^2\!</math>. The exact details of how to solve for the parameters can be found elsewhere<ref>
{{cite conference
 |author = M.J.D. Powell
 |title = A Thin Plate Spline Method for Mapping Curves into Curves in Two Dimensions
 |book-title = Computational Techniques and Applications (CTAC '95)
 |year = 1995
 |doi = 10.1142/9789814530651
 }}</ref><ref>
{{cite journal
 |author = J. Duchon
 |title = Splines Minimizing Rotation-Invariant Semi-Norms in Sobolev Spaces
 |journal = Constructive Theory of Functions of Several Variables
 |volume = 571
 |pages = 85–100
 |doi = 10.1007/BFb0086566
 |isbn = 978-3-540-08069-5
 |series = Lecture Notes in Mathematics
 |year = 1977
 }}</ref> but it essentially involves solving a [[System of linear equations|linear system of equations]]. The bending energy (a measure of how much transformation is needed to align the points) will also be easily obtained.

====Regularized TPS====
The TPS formulation above has exact matching requirement for the pairs of points on the two shapes. For noisy data, it is best to relax this exact requirement. If we let <math>v_i</math> denote the target function values at corresponding locations <math>p_i = (x_i,y_i)</math> (Note that for <math>f_x</math>, <math>v_i</math> would <math>x'</math> the x-coordinate of the point corresponding to <math>p_i</math> and for <math>f_y</math> it would be the y-coordinate, <math>y'</math>), relaxing the requirement amounts to minimizing

: <math> H[f] = \sum_{i=1}^n(v_i - f(x_i,y_i))^2 + \lambda I_f</math>

where <math>I_f\!</math> is the bending energy and <math>\lambda\!</math> is called the regularization parameter. This ''ƒ'' that minimizes ''H''[''ƒ''] can be found in a fairly straightforward way.<ref>
{{cite book
 |author = G. Wahba
 |title = Spline Models for Observational Data
 |url = https://archive.org/details/splinemodelsforo0000wahb
 |url-access = registration
 |publisher = Soc. Industrial and Applied Math
 |year = 1990|isbn = 9780898712445
 }}</ref> If one uses normalize coordinates for <math>(x_i,y_i)\mbox{ and } (x'_i,y'_i)</math>, then scale invariance is kept. However, if one uses the original non-normalized coordinates, then the regularization parameter needs to be normalized.

Note that in many cases, regardless of the transformation used, the initial estimate of the correspondences contains some errors which could reduce the quality of the transformation. If we iterate the steps of finding correspondences and estimating transformations (i.e. repeating steps 2&ndash;5 with the newly transformed shape) we can overcome this problem. Typically, three iterations are all that is needed to obtain reasonable results.

===Step 6: Computing the shape distance===
Now, a shape distance between two shapes <math>P\!</math> and <math>Q\!</math>. This distance is going to be a weighted sum of three potential terms:

'''Shape context distance''': this is the symmetric sum of shape context matching costs over best matching points:

: <math>D_{sc}(P,Q) = \frac{1}{n}\sum_{p \in P} \arg \underset{q \in Q}{\min} C(p,T(q)) + \frac{1}{m}\sum_{q \in Q} \arg \underset{p \in P}{\min} C(p,T(q))</math>

where ''T''(·) is the estimated TPS transform that maps the points in ''Q'' to those in ''P''.

'''Appearance cost''': After establishing image correspondences and properly warping one image to match the other, one can define an appearance cost as the sum of squared brightness differences in [[Gaussian filter|Gaussian windows]] around corresponding image points:

: <math>D_{ac}(P,Q) = \frac{1}{n}\sum_{i=1}^n\sum_{\Delta \in Z^2} G(\Delta)\left [I_P(p_i + \Delta) - I_Q(T(q_{\pi(i)}) + \Delta)\right ]^2</math>

where <math>I_P\!</math> and <math>I_Q\!</math> are the gray-level images (<math>I_Q\!</math> is the image after warping) and <math>G\!</math> is a Gaussian windowing function.

'''Transformation cost''': The final cost <math>D_{be}(P,Q)\!\,</math> measures how much transformation is necessary to bring the two images into alignment. In the case of TPS, it is assigned to be the bending energy.

Now that we have a way of calculating the distance between two shapes, we can use a [[k-nearest neighbor algorithm|nearest neighbor]] [[Classifier (mathematics)|classifier]] (k-NN) with distance defined as the shape distance calculated here. The results of applying this to different situations is given in the following section.

==Results==

===Digit recognition===
{{Main|MNIST database}}
The authors [[Serge Belongie]] and [[Jitendra Malik]] tested their approach on the [[MNIST database]]. Currently, more than 50 algorithms have been tested on the database. The database has a training set of 60,000 examples, and a test set of 10,000 examples. The error rate for this approach was 0.63% using 20,000 training examples and 3-NN. At the time of publication, this error rate was the lowest. Currently, the lowest error rate is 0.18%.<ref name="Kowsari2018">{{cite journal |last1=Kowsari |first1=Kamran |last2=Heidarysafa |first2=Mojtaba |last3=Brown |first3=Donald E. |last4=Meimandi |first4=Kiana Jafari |last5=Barnes |first5=Laura E. |title=RMDL: Random Multimodel Deep Learning for Classification |journal=Proceedings of the 2018 International Conference on Information System and Data Mining |date=2018-05-03 |arxiv=1805.01890 |doi=10.1145/3206098.3206111 |bibcode=2018arXiv180501890K |s2cid=19208611 }}</ref>

===Silhouette similarity-based retrieval===
The authors experimented with the MPEG-7 shape silhouette database, performing Core Experiment CE-Shape-1 part B, which measures performance of similarity-based retrieval.<ref>
{{cite journal
 |author1=S. Jeannin  |author2=M. Bober
  |name-list-style=amp |title = Description of core experiments for MPEG-7 motion/shape. Technical Report ISO/IEC JTC 1/SC 29/WG 11 MPEG99/N2690, MPEG-7, Seoul
 |date=March 1999}}</ref> The database has 70 shape categories and 20 images per shape category. Performance of a retrieval scheme is tested by using each image as a query and counting the number of correct images in the top 40 matches. For this experiment, the authors increased the number of points sampled from each shape. Also, since the shapes in the database sometimes were rotated or flipped, the authors took defined the distance between a reference shape and query shape to be minimum shape distance between the query shape and either the unchanged reference, the vertically flipped, or the reference horizontally flipped.<ref name="shape_1"/><ref name="shape_2"/><ref name="shape_3"/><ref name="shape_4"/> With these changes, they obtained a retrieval rate of 76.45%, which in 2002 was the best.
<!--  Commented out because image was deleted: [[Image:Coil_20.PNG|thumb|200px|right|Results of the experiment on COIL-20]] -->

===3D object recognition===
The next experiment performed on shape contexts involved the 20 common household objects in the [http://www1.cs.columbia.edu/CAVE/software/softlib/coil-20.php Columbia Object Image Library (COIL-20)]. Each object has 72 views in the database. In the experiment, the method was trained on a number of equally spaced views for each object and the remaining views were used for testing. A 1-NN classifier was used. The authors also developed an ''editing'' algorithm based on shape context similarity and [[k-medoid]] clustering that improved on their performance.<ref name=shape_4/>

===Trademark retrieval===
Shape contexts were used to retrieve the closest matching trademarks from a database to a query trademark (useful in detecting trademark infringement). No visually similar trademark was missed by the algorithm (verified manually by the authors).<ref name="shape_2"/>

==External links==
* [http://www.eecs.berkeley.edu/Research/Projects/CS/vision/shape/sc_digits.html Matching with Shape Contexts]
* [http://yann.lecun.com/exdb/mnist/ MNIST database of handwritten digits]
* [http://www1.cs.columbia.edu/CAVE/software/softlib/coil-20.php Columbia Object Image Library (COIL-20)]
* [http://www.vision.caltech.edu/Image_Datasets/Caltech101/ Caltech101 Database]
* [https://towardsdatascience.com/shape-context-descriptor-and-fast-characters-recognition-c031eac726f9 Character recognition with Shape Context]

==References==
<references/>

[[Category:Computer vision]]