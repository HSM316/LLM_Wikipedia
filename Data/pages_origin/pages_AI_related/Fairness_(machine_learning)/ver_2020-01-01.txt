{{Multiple issues|
{{Manual|date=December 2019}}
{{Technical|date=December 2019}}
}}
{{Rough translation|1=Spanish|date=December 2019}}
In machine learning, a given algorithm is said to be '''fair''', or to have '''fairness''' if its results are independent of some variables we consider to be sensitive and not related with it (f.e.: gender, ethnicity, sexual orientation, etc.).

== Context ==

Research about fairness in machine learning is a relatively recent topic. Most of articles about it have been written in the last three years<ref name="Articles">[https://fairmlclass.github.io/1.html#/4 ''Moritz Hardt, Berkeley'']. Retrieved 18 December 2019</ref>. Some of the most important facts in this topic are the following:
* In 2018, IBM introduces AI Fairness 360, a Python library with several algorithms to reduce bias in a program, increasing its fairness.<ref name="IBM">[https://aif360.mybluemix.net/ ''IBM AI Fairness 360'']. Retrieved 18 December 2019</ref>
* Facebook made public, in 2018, their use of a tool, Fairness Flow, to detect bias in their AI. However, said tool code is not accesible, and it is not known if it really corrects this bias.<ref name="Facebook">[https://qz.com/1268520/facebook-says-it-has-a-tool-to-detect-bias-in-its-artificial-intelligence/ ''Fairness Flow el detector de sesgos de Facebook'']. Retrieved 28 December 2019</ref>
* In 2019, Google publishes a set of tools in Github to study the effects of fairness in the long run.<ref name="Google">[https://github.com/google/ml-fairness-gym ''ML-Fairness gym'']. Retrieved 18 December 2019</ref>

A pesar de que se siguen perfeccionando los algoritmos utilizados, los principales avances vienen de la concienciación por parte de algunas grandes empresas de la importancia que va a tener en la sociedad la reducción del sesgo en los algoritmos de aprendizaje automático en un futuro.

== Fairness criteria in classification problems<ref name="Barocas">Solon Barocas; Moritz Hardt; Arvind Narayanan, [http://www.fairmlbook.org ''Fairness and Machine Learning'']. Retrieved 15 December 2019.</ref> ==

In [[Statistical classification | classification]] problems, an algorithm learns a function to predict a discrete characteristic <math display="inline"> Y </math>, the target variable, from known characteristics <math display="inline"> X </math>. We model <math display="inline"> A </math> as a discrete [[random variable]] which encodes some characteristics contained or implictly encoded in <math display="inline"> X </math> that we consider as sensitive characteristics (gender, ethnicity, sexual orientation, etc.). We finally denote by <math display="inline"> R </math> the prediction of the classifier.
Now let us define three main criteria to evaluate if a given classifier is fair, that is, if its predictions are not influenced by some of this sensitive variables.

=== Independence ===

We say the [[random variable | random variables]] <math display="inline">(R,A)</math> satisfy '''independence''' if the sensitive characteristics <math display="inline"> A </math> are [[Independence (probability theory)|statistically independent]] to the prediction <math display="inline"> R </math>, and we write <math display="inline"> R \bot A </math>.

We can also express this notion with the following formula:
<math display="block"> P(R = r | A = a) = P(R = r | A = b) \quad \forall r \in R \quad \forall a,b \in A </math>
This means that the [[probability theory | probability]] of being classified by the algorithm in each of the groups is equal for two individuals with different sensitive characteristics.

Yet another equivalent expression for independence can be given using the concept of [[mutual information]] between [[random variables]], defined as
<math display="block"> I(X,Y) = H(X) + H(Y) - H(X,Y) </math>
In this formula, <math display="inline"> H </math> of the [[random variable]]. Then <math display="inline"> (R,A) </math> satisfy independence if <math display="inline"> I(R,A) = 0 </math>.

A possible relaxation of the indepence definition include introducing a positive slack <math display="inline> \epsilon > 0 </math> and is given by the formula:
<math diplay="block"> P(R = r | A = a) \geq P(R = r | A = b) - \epsilon \quad \forall r \in R \quad \forall a,b \in A </math>

Finally, another possible relaxation is to require <math display="inline"> I(R,A) \leq \epsilon </math>.

=== Separation ===

We say the [[random variable | random variables]] <math display="inline">(R,A,Y)</math> satisfy '''separation''' if the sensitive characteristics <math display="inline"> A </math> are [[Independence (probability theory)|statistically independent]] to the prediction <math display="inline"> R </math> given the target value <math display="inline"> Y </math>, and we write <math display="inline"> R \bot A | Y </math>.

We can also express this notion with the following formula:
<math display="block"> P(R = r | Y = q, A = a) = P(R = r | Y = q, A = b) \quad \forall r \in R \quad q \in Y \quad \forall a,b \in A </math>
This means that the [[probability theory | probability]] of being classified by the algorithm in each of the groups is equal for two individuals with different sensitive characteristics given that they actually belong in the same group (have the same target variable).

Another equivalent expression, in the case of a binary target rate, is that the [[Sensitivity and specificity|true positive rate]] and the [[Sensitivity and specificity|false positive rate]] are equal (and therefore the [[Sensitivity and specificity|false negative rate]] and the [[Sensitivity and specificity|true negative rate]] are equal) for every value of the sensitive characteristics:
<math display="block"> P(R = 1 | Y = 1, A = a) = P(R = 1 | Y = 1, A = b) \quad \forall a,b \in A </math>
<math display="block"> P(R = 1 | Y = 0, A = a) = P(R = 1 | Y = 0, A = b) \quad \forall a,b \in A </math>

Finally, a possible relaxation of the given definitions is the difference between rates to be a positive number lower than a given slack <math display="inline> \epsilon > 0 </math>, instead of equals to zero.

=== Sufficiency ===

We say the [[random variable | random variables]] <math display="inline">(R,A,Y)</math> satisfy '''sufficiency''' if the sensitive characteristics <math display="inline"> A </math> are [[Independence (probability theory)|statistically independent]] to the target value <math display="inline"> Y </math> given the prediction <math display="inline"> R </math>, and we write <math display="inline"> Y \bot A | R </math>.

We can also express this notion with the following formula:
<math display="block"> P(Y = q | R = r, A = a) = P(Y = q | R = r, A = b) \quad \forall q \in Y \quad r \in R \quad \forall a,b \in A </math>
This means that the [[probability theory | probability]] of actually being in each of the groups is equal for two individuals with different sensitive characteristics given that they were predicted to belong to the same group.

=== Relationships between definitions ===

Finally, we sum up some of the main results that relate the three definitions given above:

* If <math display="inline"> A </math> and <math display="inline"> Y </math> are not [[Independence (probability theory)|statistically independent]], then sufficiency and independence cannot both hold.
* Assumming <math display="inline"> Y </math> is binary, if <math display="inline"> A </math> and <math display="inline"> Y </math> are not [[Independence (probability theory)|statistically independent]], and <math display="inline"> R </math> and <math display="inline"> Y </math> are not [[Independence (probability theory)|statistically independent]] either, then independence and separation cannot both hold.
* If <math display="inline">(R,A,Y)</math> as a [[joint distribution]] has positive [[probability theory | probability]] for all its possible values and <math display="inline"> A </math> and <math display="inline"> Y </math> are not [[Independence (probability theory)|statistically independent]], then separation and sufficiency cannot both hold.

==Metrics<ref name="metrics_paper">Sahil Verma; Julia Rubin, [https://fairware.cs.umass.edu/papers/Verma.pdf ''Fairness Definitions Explained'']. Retrieved 15 December 2019</ref>==

Most statistical measures of fairness rely on different metrics, so we will start by defining them. When working with a binary classifier, both the predicted and the actual classes can take two values: positive and negative. Now let us start explaining the different possible relations between predicted and actual outcome:[[File:Binary confusion matrix.jpg|200x150px|frame|50px|Confusion matrix]]
* '''True positive (TP)''': The case where both the predicted and the actual outcome are in the positive class.
* '''True negative (TN)''': The case where both the predicted and the actual outcome are in the negative class.
* '''False positive (FP)''': A case predicted to be in the positive class when the actual outcome is in the negative one.
* '''False negative (FN)''': A case predicted to be in the negative class when the actual outcome is in the positive one.
This relations can be easily represented with a [[confusion matrix]], a table which describes the accuracy of a classification model. In this matrix, columns and rows represent instances of the predicted and the actual cases, respectively.

By using this relations, we can define multiple metrics which can be later used to measure the fairness of an algorithm:
* '''Positive predicted value (PPV)''': the fraction of positive cases which were correctly predicted out of all the positive predictions. It is usually referred to as precision, and represents the [[probability theory | probability]] of a positive prediction to be right. It is given by the following formula:
<math display="block"> PPV = P(actual=+|prediction=+) = \frac{TP}{TP+FP}</math>
* '''False discovery rate (FDR)''': the fraction of positive predictions which were actually negative out of all the positive predictions. It represents the [[probability theory | probability]] of a positive prediction to be wrong, and it is given by the following formula:
<math display="block"> FDR = P(actual=-|prediction=+) = \frac{FP}{TP+FP} </math>
* '''Negative predicted value (NPV)''': the fraction of negative cases which were correctly predicted out of all the negative predictions. It represents the [[probability theory | probability]] of a negative prediction to be right, and it is given by the following formula:
<math display="block"> NPV = P(actual=-|prediction=-) = \frac{TN}{TN+FN} </math>
* '''False omission rate (FOR)''': the fraction of negative predictions which were actually positive out of all the negative predictions. It represents the [[probability theory | probability]] of a negative prediction to be wrong, and it is given by the following formula:
<math display="block"> FOR = P(actual=+|prediction=-) = \frac{FN}{TN+FN} </math>
* '''True positive rate (TPR)''': the fraction of positive cases which were correctly predicted out of all the positive cases. It is usually referred to as sensitivity or recall, and it represents the [[probability theory | probability]] of the positive subjects to be classified correctly as such. It is given by the formula:
<math display="block"> TPR = P(prediction=+|actual=+) = \frac{TP}{TP+FN} </math>
* '''False negative rate (FNR)''': the fraction of positive cases which were incorrectly predicted to be negative out of all the positive cases. It represents the [[probability theory | probability]] of the positive subjects to be classified incorrectly as negative ones, and it is given by the formula:
<math display="block"> FNR = P(prediction=-|actual=+) = \frac{FN}{TP+FN} </math>
* '''True negative rate (TNR)''': the fraction of negative cases which were correctly predicted out of all the negative cases. It represents the [[probability theory | probability]] of the negative subjects to be classified correctly as such, and it is given by the formula:
<math display="block"> TNR = P(prediction=-|actual=-) = \frac{TN}{TN+FP} </math>
* '''False positive rate (FPR)''': the fraction of negative cases which were incorrectly predicted to be positive out of all the negative cases. It represents the [[probability theory | probability]] of the negative subjects to be classified incorrectly as positive ones, and it is given by the formula:
<math display="block"> FPR = P(prediction=+|actual=-) = \frac{FP}{TN+FP} </math>

== Other fairness criteria ==

[[File:RelationsEng.jpg|250x400px|frame|50px|Relationship between fairnes criteria as shown in Barocas et al.<ref name="Barocas"/>]]
The following criteria can be understood as measures of the three definitions given on the first section, or a relaxation of them. In the table<ref name="Barocas"/> to the right we can see the relationships between them.

To define this measures specifically, we will divide them into three big groups as done in Verma et al.<ref name="metrics_paper"/>: definitions based on predicted outcome, on predicted and actual outcomes, and definitions based on predicted probabilities and actual outcome.

We will be working with a binary classifier and the folowing notation: <math display="inline"> S </math> refers to the score given by the classifier, which is the probability of a certain subject to be in the positive or the negative class.<math display="inline"> R </math> represents the final classification predicted by the algorithm, and its value is usually derived from <math display="inline"> S </math>, for example will be positive when <math display="inline"> S </math> is above a certain threshold.<math display="inline"> Y </math> represents the actual outcome, that is, the real classification of the individual and, finally, <math display="inline"> A </math> denotes the sensitive attributes of the subjects.

=== Definitions based on predicted outcome ===

The definitions in this section focus on a predicted outcome <math display="inline"> R </math> for various distributions of subjects. They are the simplest and most intuitive notions of fairness.

* '''Group fairness''', also referred to as '''statistical parity''', '''demographic parity''', '''acceptance rate''' and '''benchmarking'''. A classifier satisfies this definition if the subjects in the protected and unprotected groups have equal probability of being assigned to the positive predicted class. This is, if the following formula is satisfied:
<math display="block"> P(R = +|A = a) = P(R = +|A = b) \quad \forall a,b \in A </math>

* '''Conditional statistical parity'''. Basically consists in the definition above, but restricted only to a subset of the attributes. With mathematical notation this would be:
<math display="block"> P(R = +|L = l, A = a) = P(R = +|L = l, A = b) \quad \forall a,b \in A \quad \forall l \in L </math>

=== Definitions based on predicted and actual outcomes ===

This definitions not only consider de predicted outcome <math display="inline"> R </math> but also compare it to the actual outcome <math display="inline"> Y </math>.

* '''Predictive parity''', also referred to as '''outcome test'''. A classifier satisfies this definition if the subjects in the protected and unprotected groups have equal PPV. This is, if the following formula is satisfied:
<math display="block"> P(Y = + | R = +, A = a) = P(Y = + | R = +, A = b) \quad \forall a,b \in A </math>
: Mathematically, if a classifier has equal PPV for both groups, it will also have equal FDR, satisfying the formula:
<math display="block"> P(Y = - | R = +, A = a) = P(Y = - | R = +, A = b) \quad \forall a,b \in A </math>

* '''False positive error rate balance''', also referred to as '''predictive equality'''. A classifier satisfies this definition if the subjects in the protected and unprotected groups have aqual FPR. This is, if the following formula is satisfied:
<math display="block"> P(R = + | Y = -, A = a) = P(R = + | Y = -, A = b) \quad \forall a,b \in A </math>
: Mathematically, if a classifier has equal FPR for both groups, it will also have equal TNR, satisfying the formula:
<math display="block"> P(R = - | Y = -, A = a) = P(R = - | Y = -, A = b) \quad \forall a,b \in A </math>

* '''False negative error rate balance''', also referred to as '''equal opportunity'''. A classifier satisfies this definition if the subjects in the protected and unprotected groups have equal FNR. This is, if the following formula is satisfied:
<math display="block"> P(R = - | Y = +, A = a) = P(R = - | Y = +, A = b) \quad \forall a,b \in A </math>
: Mathematically, if a classifier has equal FNR for both groups, ti will also have equal TPR, satisfying the formula:
<math display="block"> P(R = + | Y = +, A = a) = P(R = + | Y = +, A = b) \quad \forall a,b \in A </math>

* '''Equalized odds''', also referred to as '''conditional procedure accuracy equality''' and '''disparate mistreatment'''. A classifier satisfies this definition if the subjects in the protected and unprotected groups have equal TPR and equal FPR, satisfying the formula:
<math display="block"> P(R = + | Y = y, A = a) = P(R = + | Y = y, A = b) \quad y \in \{+,-\} \quad \forall a,b \in A </math>

* '''Conditional use accuracy equality'''. A classifier satisfies this definition if the subjects in the protected and unprotected groups have equal PPV and equal NPV, satisfying the formula:
<math display="block"> P(Y = y | R = y, A = a) = P(Y = y | R = y, A = b) \quad y \in \{+,-\} \quad \forall a,b \in A </math>

* '''Overall accuracy equality'''. A classifier satisfies this definition if the subject in the protected and unprotected groups have equal prediction accuracy, that is, the probability of a subject from one class to be assigned to it. This is, if it satisfies the following formula:
<math display="block"> P(R = Y , A = a) = P(R = Y | A = b) \quad \forall a,b \in A </math>

* '''Treatment equality'''. A classifier satisfies this definition if the subjects in the protected and unprotected groups have an equal ratio of FN and FP, satisfying the formula:
<math display="block"> \frac{FN_{A=a}}{FP_{A=a}} = \frac{FN_{A=b}}{FP_{A=b}} </math>

=== Definitions based on predicted probabilities and actual outcome ===

These definitions are based in the actual outcome <math display="inline"> Y </math> and the predicted probability score <math display="inline"> S </math>.

* '''Test-fairness''', also known as '''calibration''' or '''matching conditional frequencies'''. A classifier satisfies this definition if individuals with the same predicted probability score <math display="inline"> S </math> have the same probability to be classified in the positive class when they belong to either the protected or the unprotected group:
<math display="block"> P(Y = +|S = s,A = a) = P(Y = +|S = s,A = b) \quad \forall s \in S \quad \forall a,b \in A </math>

* '''Well-calibration'''. It's an extension of the previous definition. It states that when individuals inside or outside the protected group have the same predicted probability score <math display="inline"> S </math> they must have the same probability of being classified in the positive class, and this probability must be equal to <math display="inline"> S </math>:
<math display="block"> P(Y = +|S = s,A = a) = P(Y = +|S = s,A = b) = s \quad \forall s \in S \quad \forall a,b \in A </math>

* '''Balance for positive class'''. A classifier satisfies this definition if the subjects constituting the positive class from both protected and unprotected groups have equal average predicted probability score <math display="inline"> S </math>. This means that the expected value of probability score for the protected and unprotected groups with positive actual outcome <math display="inline"> Y </math> is the same, satisfying the formula:
<math display="block"> E(S|Y = +,A = a) = E(S|Y = +,A = b) \quad \forall a,b \in A </math>

* '''Balance for negative class'''. A classifier satisfies this definition if the subjects constituting the negative class from both protected and unprotected groups have equal average predicted probability score <math display="inline"> S </math>. This means that the expected value of probability score for the protected and unprotected groups with negative actual outcome <math display="inline"> Y </math> is the same, satisfying the formula:
<math display="block"> E(S|Y = -,A = a) = E(S|Y = -,A = b) \quad \forall a,b \in A </math>

== Algorithms ==

Fairness can be applied to machine learning algorithms in three different ways: preprocessing the data used in the algorithm, optimization during the training, or post-processing the answers of the algorithm.

=== Preprocessing ===

Usually, the classifier is not the only problem, the dataset is also biased. The discrimination of a dataset <math display="inline"> D </math> with respect to the group <math display="inline"> A = a </math> can be defined as follows:
<math display="block"> disc_{A=a}(D) = \frac{|\{X\in D| X(A) \neq a, X(Y) = +\}|}{|\{X \in D | X(A) \neq a \}|} - \frac{|\{X\in D| X(A) = a, X(Y) = +\}|}{|\{X \in D | X(A) = a \}|}</math>

That is, an approximation to the difference between the probabilities of belonging in the positive class given that the subject has a protected characteristic different from <math display="inline"> a </math> and equal to <math display="inline"> a </math>.

Algorithms correcting bias at preprocessing remove information concerning variables in the dataset which can result in unfair decisions of the AI, while trying to alter just the bare minimum of this data. This is not as easy as just removing the sensitive variable, because other attributes can be related to the protected one.

A way to do this is by mapping each individual in the initial dataset into an intermediate representation in which its impossible to identify if it belongs to a particular protected group, while maintaining as much information as possible. Then, the new representation of the data is adjusted to get the maximum accuracy in the algorithm.
 
This way, individuals are mapped into a new multivariable representation where the probability of any member of a protected group to be mapped to a certain value in the new representation is the same as the probability of an individual which doesn’t belong to the protected group. Then, this representation is used to obtain the prediction for the individual, instead of the initial data. As the intermediate representation is constructed giving the same probability to individuals inside or outside the protected group, this attribute is hidden to the classificator.

An example is explained in Zemel et al.<ref name="zemel"> Richard Zemel; Yu (Ledell) Wu; Kevin Swersky; Toniann Pitassi; Cyntia Dwork, [https://www.cs.toronto.edu/~toni/Papers/icml-final.pdf ''Learning Fair Representations'']. Retrieved 1 December 2019</ref> where a multinomial random variable is used as intermediate representation. In the process, the system is encouraged to preserve all the information except those that can lead to biased decisions, and to obtain a prediction as accurate as possible.

On the one hand, this procedure has the advantage that the preprocessed data can be used for any machine learning task. Furthermore, the classifier does not need to be modified, as the correction is applied to the dataset before processing. On the other hand, the other methods obtain better results in accuracy and fairness.<ref name="datascience"> Ziyuan Zhong, [https://towardsdatascience.com/a-tutorial-on-fairness-in-machine-learning-3ff8ba1040cb ''Tutorial on Fairness in Machine Learning'']. Retrieved 1 December 2019</ref>

==== Reweighing<ref name="reweighing"> Faisal Kamiran; Toon Calders, [https://link.springer.com/content/pdf/10.1007%2Fs10115-011-0463-8.pdf ''Data preprocessing techniques for classification without discrimination'']. Retrieved 17 December 2019</ref> ====

Reweighing is an example of preprocessing algorithm. The idea is to assign a weight to each dataset point such that the weighted discrimination is 0 with respect to the designated group.

If the dataset <math display="inline"> D </math> was unbiased the sensitive variable <math display="inline"> A </math> and the target variable <math display="inline"> Y </math> would be [[Independence (probability theory)|statistically independent]] and the probability of the [[Joint probability distribution|joint distribution] would be the product of the probabilities as follows:
<math display="block"> P_{exp}(A = a \wedge Y = +) = P(A = a) \times P(Y = +) = \frac{|\{X \in D | X(A) = a\}|}{|D|} \times \frac{|\{X \in D| X(Y) = + \}|}{|D|}</math>

In reality, however, the dataset is not unbiased and the variables are not [[Independence (probability theory)|statistically independent]] so the observed probability is:
<math display="block"> P_{obs}(A = a \wedge Y = +) = \frac{|\{X \in D | X(A) = a \wedge X(Y) = +\}|}{|D|} </math>

To compensate for the bias, lower weights to favored objects and higher weights to unfavored objects will be assigned. For each <math display="inline"> X \in D </math> we get:
<math display="block"> W(X) = \frac{P_{exp}(A = X(A) \wedge Y = X(Y))}{P_{obs}(A = X(A) \wedge Y = X(Y))} </math>

When we have for each <math display="inline"> X </math> a weight associated <math display="inline"> W(X) </math> we compute the weighted discrimination with respect to group <math display="inline"> A = a </math> as follows:
<math display="block"> disc_{A = a}(D) = \frac{\sum W(X) X \in \{X\in D| X(A) \neq a, X(Y) = +\}}{\sum W(X) X \in \{X \in D | X(A) \neq a \}} - \frac{\sum W(X) X \in \{X\in D| X(A) = a, X(Y) = +\}}{\sum W(X) X \in \{X \in D | X(A) = a \}} </math>

It can be shown that after reweighting this weighted discrimination is 0.

===Optimization at training time===

Another approach is correcting the bias at training time. This can be done by adding constraints to the optimization objective of the algorithm.<ref name="zafar"> Muhammad Bilal Zafar; Isabel Valera; Manuel Gómez Rodríguez; Krishna P. Gummadi, [https://people.mpi-sws.org/~mzafar/papers/disparate_mistreatment.pdf ''Fairness Beyond Disparate Treatment & Disparate Impact: Learning Classification without Disparate Mistreatment'']. Retrieved 1 December 2019</ref> These constraints force the algorithm to improve fairness, by keeping the same rates of certain measures for the protected group and the rest of individuals. For example, we can add to the objective of the algorithm the condition that the false positive rate is the same for individuals in the protected group and the ones outside the protected group.

The main measures used in this approach are false positive rate, false negative rate and overall misclassification rate. It is possible to add just one or several of these constraints to the objective of the algorithm. Note that the equality of false negative rates implies the equality of true positive rates so this implies the equality of opportunity. After adding the restrictions to the problem it may turn intractable, so a relaxation on them may be needed.

This technique obtains good results in improving fairness while keeping high accuracy, and lets the programmer to choose the fairness measures to improve. However, each machine learning task may need a different method to be applied and the code in the classifier needs to be modified, which is not always possible.<ref name="datascience"/>

==== Adversarial debiasing<ref name="adversarial1"> Brian Hu Zhang; Blake Lemoine; Margaret Mitchell, [https://arxiv.org/pdf/1801.07593.pdf ''Mitigating Unwanted Biases with Adversarial Learning'']. Retrieved 17 December 2019</ref><ref name="adversarial2"> Joyce Xu, [https://towardsdatascience.com/algorithmic-solutions-to-algorithmic-bias-aef59eaf6565 ''Algorithmic Solutions to Algorithmic Bias: A Technical Guide'']. Retrieved 17 December 2019</ref> ====

We train two [[Statistical classification|classifiers]] at the same time through some gradient-based method (f.e.: [[gradient descent]]). The first one, the ''predictor'' tries to accomplish the task of predicting <math display="inline"> Y </math>, the target variable, given <math display="inline"> X </math>, the input, by modifying its weights <math display="inline"> W </math> to minimize some [[loss function]] <math display="inline">L_{P}(\hat{y},y)</math>. The second one, the ''adversary'' tries to accomplish the task of predicting <math display="inline"> A </math>, the sensitive variable, given <math display="inline"> \hat{Y} </math> by modifying its weights <math display="inline"> U </math> to minimize some loss function <math display="inline">L_{A}(\hat{a},a) </math>.

An important point here is that, in order to propagate correctly, <math display="inline"> \hat{Y} </math> above must refer to the raw output of the classifier, not the discrete prediction; for example, with an [[artificial neural network]] and a classification problem, <math display="inline"> \hat{Y} </math> could refer to the output of the softmax layer.

Then we update <math display="inline"> U </math> to minimize <math display="inline"> L_{A} </math> at each training step according to the [[gradient]] <math display="inline"> \nabla_{U}L_{A} </math> and we modify <math display="inline"> W </math> according to the expression:
<math display="block"> \nabla_{W}L_{P} - proj_{\nabla_{W}L_{A}}\nabla_{W}L_{P} - \alpha \nabla_{W}L_{A} </math>
where <math display="alpha"> \alpha </math> is a tuneable hyperparameter that can vary at each time step.

[[File:AdvFig2.jpg|100x150px|frame|50px|Graphic representation of the vectors used in adversarial debiasing as shown in Zhan et al.<ref name=adversarial1/>]]
The intuitive idea is that we want the ''predictor'' to try to minimize <math display="inline"> L_{P} </math> (therefore the term <math display="inline"> \nabla_{W}L_{P} </math>) while, at the same time, maximize <math display="inline"> L_{A} </math> (therefore the term <math display="inline"> - \alpha \nabla_{W}L_{A} </math>), so that the ''adversary'' fails at predicting the sensitive variable from  <math display="inline"> \hat{Y} </math>.

The term <math display="inline"> -proj_{\nabla_{W}L_{A}}\nabla_{W}L_{P} </math> prevents the ''predictor'' from moving in a direction that helps the ''adversary'' decrease its loss function.

It can be shown that training a ''predictor'' classification model with this algorithm improves [[#Definitions based on predicted outcome | demographic parity]] with respect to training it without the ''adversary''.

===Postprocessing===

The final method tries to correct the results of a classifier to achieve fairness. In this method we have a classifier which returns a score for each individual and we need to do a binary prediction for them. High scores are likely to get a positive answer, while low scores are likely to get a negative answer, but we need to adjust the threshold to determine when to answer yes or no depending on our needs. Note that variations in the threshold affect the trade-off between true positive rate and true negative rate.

If the score function is fair in the sense that it’s independent of the protected attribute, then any choice of the threshold will also be fair, but this type of classifiers tend to be biased, so we may need to set a different threshold for each protected group to achieve fairness. A way to do this is plotting the true positive rate against the false negative rate at various threshold settings (this is called ROC curve) and check which threshold satisfies that the rates are equal for the protected group and the rest of the individuals.<ref name="hardt"> Moritz Hardt; Eric Price; Nathan Srebro, [https://arxiv.org/pdf/1610.02413.pdf ''Equality of Opportunity in Supervised Learning'']. Retrieved 1 December 2019</ref>

The advantages of postprocessing include that the technique can be applied after any classifiers, without modifying it, and has a good performance in fairness measures. The cons are the need to access to the protected attribute in test time and the lack of choice in the balance between accuracy and fairness.<ref name="datascience"/>

==== Reject Option based Classification<ref name="roc"> Faisal Kamiran; Asim Karim; Xiangliang Zhang, [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.722.3030&rep=rep1&type=pdf ''Decision Theory for Discrimination-aware Classification'']. Retrieved 17 December 2019</ref> ====

Given a [[Statistical classification|classifier]] let <math display="inline"> P(+|X) </math> be the probability computed by the classifiers as the probability that the instance <math display="inline"> X </math> belongs to the positive class +. When <math display="inline"> P(+|X) </math> is close to 1 or to 0, the instance <math display="inline"> X </math> is specified with high degree of certainty to belong to class + or - respectively. However, when <math display="inline"> P(+|X) </math> is closer to 0.5 the classification is more unclear.

We say <math display="inline"> X </math> is a "rejected instance" if <math display="inline"> max(P(+|X), 1-P(+|X)) \leq \theta </math> with a certain <math display="inline"> \theta </math> such that <math display="inline"> 0.5 < \theta < 1 </math>.

The algorithm of "ROC" consists on classifying the non rejected instances following the rule above and the rejected instances as follows: if the instance is an example of a deprived group (<math>X(A) = a</math>) then label it as positive, otherwise label it as negative.

We can optimize different measures of discrimination (link) as functions of <math display="inline"> \theta </math> to find the optimal <math display="inline"> \theta </math> for each problem and avoid becoming discriminatory against the privileged group.

== See also ==

* [[Algorithmic bias]]
* [[Machine learning]]

== References ==
<references />

[[Category:Machine learning]]
[[Category:Information ethics]]
[[Category:Computing and society]]
[[Category:Philosophy of artificial intelligence]]
[[Category:Discrimination]]
[[Category:Bias]]