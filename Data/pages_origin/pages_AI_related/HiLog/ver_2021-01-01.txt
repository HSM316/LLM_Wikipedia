'''HiLog''' is a programming [[logic]] with higher-order syntax, which allows arbitrary terms to appear in predicate and function positions.<ref name="hilog-jlp">{{cite journal |last1=Chen |first1=Weidong |last2=Kifer |first2=Michael |last3=Warren |first3=David S. |date=February 1993 |title=HiLog: A foundation for higher-order logic programming |journal=[[Journal of Logic Programming]] |volume=15 |issue=3 |pages=187–230 |doi=10.1016/0743-1066(93)90039-J}} {{CiteSeerX|10.1.1.52.7860}}</ref> However, the [[model theory]] of HiLog is first-order. Although syntactically HiLog strictly extends [[first order logic]], HiLog can be embedded into this logic.

HiLog was first described in 1989.<ref>{{cite conference |last1=Chen |first1=Weidong |last2=Kifer |first2=Michael |last3=Warren |first3=David S. |date=1989 |url=http://citeseerx.ist.psu.edu/showciting?cid=2016805 |title=HiLog: a first order semantics for higher-order logic programming constructs |book-title=Proc. North American Logic Programming Conference}}</ref> It was later extended in the direction of [[many-sorted logic]].<ref>{{cite book |last1=Chen |first1=Weidong |last2=Kifer |first2=Michael |date=1995 |chapter=Sorted HiLog: sorts in higher-order logic data languages |editor1-last=Gottlob |editor1-first=Georg |editor2-last=Vardi |editor2-first=Moshe Y. |title=Database theory—ICDT '95: 5th International Conference, Prague, Czech Republic, January 11–13, 1995: proceedings |series=Lecture notes in computer science |volume=893 |location=Berlin; New York |publisher=[[Springer-Verlag]] |pages=252–265 |isbn=9780387589077 |oclc=31740400 |doi=10.1007/3-540-58907-4_20}} {{CiteSeerX|10.1.1.56.4332}}</ref>

The [[XSB]] system parses HiLog syntax, but the integration of HiLog into XSB is only partial. In particular, HiLog is not integrated with the XSB module system. A full implementation of HiLog is available in the [[Flora-2]] system.

It has been shown that HiLog can be embedded into [[first-order logic]] through a fairly simple transformation.<ref name="hilog-jlp"/> For instance, <code>p(X)(Y,Z(V)(W))</code> gets embedded as the following first-order term: <code>apply(p(X),Y,apply(apply(Z,V),W))</code>.<ref name="hilog-jlp"/>

The [[Rule Interchange Format#FLD|Framework for Logic-Based Dialects]] (RIF-FLD) of the [[Rule Interchange Format]] (RIF) is largely based on the ideas underlying HiLog and [[F-logic]].<ref>{{cite book |last=Kifer |first=Michael |date=2008 |chapter=Rule interchange format: the framework |editor1-last=Calvanese |editor1-first=Diego |editor2-last=Lausen |editor2-first=Georg |title=Web reasoning and rule systems: second international conference, RR 2008, Karlsruhe, Germany, October 31–November 1, 2008: proceedings |series=Lecture notes in computer science |volume=5341 |location=Berlin; New York |publisher=[[Springer-Verlag]] |pages=1–11 |isbn=9783540887362 |oclc=262884460 |doi=10.1007/978-3-540-88737-9_1 |ref=harv}} {{CiteSeerX|10.1.1.150.6922}}</ref>

== Examples ==

In all the examples below, capitalized symbols denote variables and the comma denotes [[logical conjunction]], as in most [[logic programming]] languages. The first and the second examples show that variables can appear in predicate positions. Predicates can even be complex terms, such as <code>closure(P)</code> or <code>maplist(F)</code> below. The third example shows that variables can also appear in place of atomic formulas, while the fourth example illustrates the use of variables in place of function symbols. The first example defines a generic [[transitive closure]] operator, which can be applied to an arbitrary binary predicate. The second example is similar. It defines a [[LISP]]-like mapping operator, which applies to an arbitrary binary predicate. The third example shows that the [[Prolog]] meta-predicate <code>call/1</code> can be expressed in HiLog in a natural way and without the use of extra-logical features. The last example defines a predicate that traverses arbitrary binary trees represented as [[Term (logic)|first-order term]]s.
<syntaxhighlight lang="prolog">
closure(P)(X,Y) <- P(X,Y).
closure(P)(X,Y) <- P(X,Z), closure(P)(Z,Y).

maplist(F)([],[]).
maplist(F)([X|R],[Y|Z]) <- F(X,Y), maplist(F)(R,Z).

call(X) <- X.

traverse(X(L,R)) <- traverse(L), traverse(R).
</syntaxhighlight>

==References==
{{reflist}}

==Further reading==
* {{cite journal |last=Ross |first=Kenneth A. |date=January 1994 |title=On negation in HiLog |journal=[[Journal of Logic Programming]] |volume=18 |issue=1 |pages=27–53 |doi=10.1016/0743-1066(94)90040-X |ref=harv}} {{CiteSeerX|10.1.1.55.2148}}
* {{cite journal |last1=Bruijn |first1=Jos |last2=Heymans |first2=Stijn |date=January 2008 |title=On the relationship between description logic-based and F-logic-based ontologies |journal=[[Fundamenta Informaticae]] |volume=82 |issue=3 |pages=213–236 |url=https://content.iospress.com/articles/fundamenta-informaticae/fi82-3-02 |ref=harv}} {{CiteSeerX|10.1.1.602.2421}}

[[Category:Logic programming languages]]
[[Category:Declarative programming languages]]
[[Category:Knowledge representation]]