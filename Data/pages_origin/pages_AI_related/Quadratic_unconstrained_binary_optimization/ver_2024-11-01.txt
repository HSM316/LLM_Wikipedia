{{Short description|Combinatorial optimization problem}}
<!-- {{refimprove|date=September 2014}} -->
'''Quadratic unconstrained binary optimization''' ('''QUBO'''), also known as '''unconstrained binary quadratic programming''' ('''UBQP'''), is a combinatorial [[optimization problem]] with a wide range of applications from [[finance]] and [[economics]] to [[machine learning]].<ref>{{cite journal |last1=Kochenberger |first1=Gary |last2=Hao |first2=Jin-Kao |first3=Fred |last3=Glover |first4=Mark |last4=Lewis |first5=Zhipeng|last5=Lu |first6=Haibo |last6=Wang |first7=Yang |last7=Wang |title=The unconstrained binary quadratic programming problem: a survey. |journal=Journal of Combinatorial Optimization |date=2014 |volume=28 |pages=58–81 |doi=10.1007/s10878-014-9734-0 |s2cid=16808394 |url=https://leeds-faculty.colorado.edu/glover/454%20-%20xQx%20survey%20article%20as%20published%202014.pdf}}</ref> QUBO is an [[NP hard]] problem, and for many classical problems from [[theoretical computer science]], like [[maximum cut]], [[graph coloring]] and the [[partition problem]], embeddings into QUBO have been formulated.<ref name="tut">{{cite arXiv |last1=Glover |first1=Fred |last2=Kochenberger|first2=Gary |eprint=1811.11538 |title=A Tutorial on Formulating and Using QUBO Models |class= cs.DS|date=2019 }}</ref><ref>{{cite journal |last1=Lucas |first1=Andrew |title=Ising formulations of many NP problems |journal=Frontiers in Physics |date=2014 |volume=2 |page=5 |doi=10.3389/fphy.2014.00005 |arxiv=1302.5843 |bibcode=2014FrP.....2....5L |doi-access=free }}</ref>
Embeddings for machine learning models include [[support-vector machine|support-vector machines]], [[cluster analysis|clustering]] and [[probabilistic graphical model|probabilistic graphical models]].<ref>{{cite journal |last1=Mücke |first1=Sascha |last2=Piatkowski |first2=Nico |last3=Morik |first3=Katharina |author3-link=Katharina Morik|title=Learning Bit by Bit: Extracting the Essence of Machine Learning |journal=LWDA |date=2019 |s2cid=202760166 |url=https://pdfs.semanticscholar.org/f484/b4a789e1563b91a416a7cfabbf72f0aa3b2a.pdf |archive-url=https://web.archive.org/web/20200227143739/https://pdfs.semanticscholar.org/f484/b4a789e1563b91a416a7cfabbf72f0aa3b2a.pdf |url-status=dead |archive-date=2020-02-27 }}</ref>
Moreover, due to its close connection to [[Ising model|Ising models]], QUBO constitutes a central problem class for [[adiabatic quantum computing|adiabatic quantum computation]], where it is solved through a physical process called [[quantum annealing]].<ref>{{cite web
 |url          = http://www.technologyreview.com/view/514686/d-waves-quantum-computer-goes-to-the-races-wins/
 |title        = D-Wave's Quantum Computer Goes to the Races, Wins
 |author       = Tom Simonite
 |publisher    = MIT Technology Review
 |date         = 8 May 2013
 |access-date  = 12 May 2013
 |archive-date = 24 September 2015
 |archive-url  = https://web.archive.org/web/20150924141050/http://www.technologyreview.com/view/514686/d-waves-quantum-computer-goes-to-the-races-wins/
 |url-status   = dead
}}</ref>

==Definition==

The set of [[binary data|binary]] vectors of a fixed length <math>n>0</math> is denoted by <math>\mathbb{B}^n</math>, where <math>\mathbb{B}=\lbrace 0,1\rbrace</math> is the set of binary values (or ''bits'').
We are given a real-valued upper [[triangular matrix]] <math>Q\in\mathbb{R}^{n\times n}</math>, whose entries <math>Q_{ij}</math> define a weight for each pair of indices <math>i,j\in\lbrace 1,\dots,n\rbrace</math> within the binary vector.
We can define a function <math>f_Q: \mathbb{B}^n\rightarrow\mathbb{R}</math> that assigns a value to each binary vector through
: <math>f_Q(x) = x^\top Qx = \sum_{i=1}^n \sum_{j=i}^n Q_{ij} x_i x_j</math>

Intuitively, the weight <math>Q_{ij}</math> is added if both <math>x_i</math> and <math>x_j</math> have value 1.
When <math>i=j</math>, the values <math>Q_{ii}</math> are added if <math>x_i=1</math>, as <math>x_ix_i=x_i</math> for all <math>x_i\in\mathbb{B}</math>.

The QUBO problem consists of finding a binary vector <math>x^*</math> that is minimal with respect to <math>f_Q</math>, namely
: <math>\forall x\in\mathbb{B}^n: ~f_Q(x^*)\leq f_Q(x)</math>

In general, <math>x^*</math> is not unique, meaning there may be a set of minimizing vectors with equal value w.r.t. <math>f_Q</math>.
The complexity of QUBO arises from the number of candidate binary vectors to be evaluated, as <math>|\mathbb{B}^n|=2^n</math> grows exponentially in <math>n</math>.

Sometimes, QUBO is defined as the problem of ''maximizing'' <math>f_Q</math>, which is equivalent to minimizing <math>f_{-Q}=-f_Q</math>.

==Properties==

QUBO is scale invariant for positive factors <math>\alpha>0</math>, which leave the optimum <math>x^*</math> unchanged:
: <math>f_{\alpha Q}(x) = \sum_{i\leq j}(\alpha Q_{ij})x_ix_j = \alpha\sum_{i\leq j}Q_{ij}x_ix_j = \alpha f_Q(x)</math>

In its general form, QUBO is [[NP-hardness|NP-hard]] and cannot be solved efficiently by any polynomial-time algorithm.<ref name="punnen2022"/>
However, there are polynomially-solvable special cases, where <math>Q</math> has certain properties,<ref name="cela2022"/> for example:

* If all coefficients are positive, the optimum is trivially <math>x^*=(0,\dots,0)</math>. Similarly, if all coefficients are negative, the optimum is <math>x^*=(1,\dots,1)</math>.
* If <math>Q</math> is [[diagonal matrix|diagonal]], the bits can be optimized independently, and the problem is solvable in <math>\mathcal{O}(n)</math>. The optimal variable assignments are simply <math>x^*_i=1</math> if <math>Q_{ii}<0</math>, and <math>x^*_i=0</math> otherwise.
* If all off-diagonal elements of <math>Q</math> are non-positive, the corresponding QUBO problem is solvable in polynomial time.<ref>See Theorem 3.16 in Punnen (2022); note that the authors assume the ''maximization'' version of QUBO.</ref>

QUBO can be solved using [[integer linear programming]] solvers like [[CPLEX]] or [[Gurobi Optimizer]].
This is possible since QUBO can be reformulated as a linear constrained binary optimization problem.
To achieve this, substitute the product <math>x_ix_j</math> by an additional binary variable <math>z_{ij}\in\{0,1\}</math> and add the constraints <math>x_i\ge z_{ij}</math>, <math>x_j\ge z_{ij}</math> and <math>x_i+x_j-1\le z_{ij}</math>.
Note that <math>z_{ij}</math> can also be [[Linear programming relaxation|relaxed]] to continuous variables within the bounds zero and one.

==Applications==

QUBO is a structurally simple, yet computationally hard optimization problem.
It can be used to encode a wide range of optimization problems from various scientific areas.<ref>{{cite web |url=https://blog.xa0.de/post/List-of-QUBO-formulations/ |title=List of QUBO formulations |last=Ratke |first=Daniel |date=2021-06-10 |access-date=2022-12-16}}</ref>

===Cluster Analysis===

{{multiple image
 | align = right
 | direction = vertical
 | width = 200
 | header = Binary Clustering with QUBO
 | image1 = Qubo-clustering-1.svg
 | alt1 = 20 points with random cluster assignment
 | caption1 = A bad cluster assignment.
 | image2 = Qubo-clustering-2.svg
 | alt2 = 20 points with sensible cluster assignment
 | caption2 = A good cluster assignment.
 | footer = Visual representation of a clustering problem with 20 points: Circles of the same color belong to the same cluster. Each circle can be understood as a binary variable in the corresponding QUBO problem.
}}

As an illustrative example of how QUBO can be used to encode an optimization problem, we consider the problem of [[cluster analysis]].
Here, we are given a set of 20 points in 2D space, described by a matrix <math>D\in\mathbb{R}^{20\times 2}</math>, where each row contains two [[cartesian coordinate system|cartesian coordinates]].
We want to assign each point to one of two classes or ''clusters'', such that points in the same cluster are similar to each other.
For two clusters, we can assign a binary variable <math>x_i\in\mathbb{B}</math> to the point corresponding to the <math>i</math>-th row in <math>D</math>, indicating whether it belongs to the first (<math>x_i=0</math>) or second cluster (<math>x_i=1</math>).
Consequently, we have 20 binary variables, which form a binary vector <math>x\in\mathbb{B}^{20}</math> that corresponds to a cluster assignment of all points (see figure).

One way to derive a  clustering is to consider the pairwise distances between points.
Given a cluster assignment <math>x</math>, one of <math>x_ix_j</math> or <math>(1-x_i)(1-x_j)</math> evaluates to 1 if points <math>i</math> and <math>j</math> are in the same cluster.
Similarly, one of <math>x_i(1-x_j)</math> or <math>(1-x_i)x_j</math> indicates that they are in different clusters.
Let <math>d_{ij}\geq 0</math> denote the [[Euclidean distance]] between points <math>i</math> and <math>j</math>.
In order to define a cost function to minimize, when points <math>i</math> and <math>j</math> are in the same cluster we add their positive distance <math>d_{ij}</math>, and subtract it when they are in different clusters.
This way, an optimal solution tends to place points which are far apart into different clusters, and points that are close into the same cluster.
The cost function thus comes down to
: <math>\begin{align}
    f(x) &= \sum_{i<j}d_{ij}(x_ix_j + (1-x_i)(1-x_j))-d_{ij}(x_i(1-x_j)+(1-x_i)x_j) \\
         &= \sum_{i<j}\left[4d_{ij}x_ix_j-2d_{ij}x_i-2d_{ij}x_j+d_{ij}\right]
  \end{align}</math>

From the second line, the QUBO parameters can be easily found by re-arranging to be:
: <math>\begin{align}
    Q_{ij} &= \begin{cases}
      d_{ij} &\text{if } i\neq j \\
      -\left(\sum\limits_{k=1}^{i-1} d_{ki} +\sum\limits_{\ell=i+1}^n d_{i\ell}\right)&\text{if } i=j
    \end{cases}
  \end{align}</math>

Using these parameters, the optimal QUBO solution will correspond to an optimal cluster w.r.t. above cost function.

==Connection to Ising models==

QUBO is very closely related and computationally equivalent to the [[Ising model]], whose [[Hamiltonian function]] is defined as
: <math>H(\sigma) = -\sum_{\langle i~j\rangle} J_{ij} \sigma_i \sigma_j - \mu \sum_j h_j \sigma_j</math>
with real-valued parameters <math>h_j, J_{ij}, \mu</math> for all <math>i,j</math>.
The ''spin variables'' <math>\sigma_j</math> are binary with values from <math>\lbrace -1,+1\rbrace</math> instead of <math>\mathbb{B}</math>.
Moreover, in the Ising model the variables are typically arranged in a lattice where only neighboring pairs of variables <math>\langle i~j\rangle</math> can have non-zero coefficients.
Applying the identity <math>\sigma\mapsto 2x-1</math> yields an equivalent QUBO problem:<ref name="tut"/>
: <math>\begin{align}f(x) &= \sum_{\langle i~j\rangle} -J_{ij}(2x_i-1)(2x_j-1) +\sum_{j}\mu h_j(2x_j-1) \\
&= \sum_{\langle i~j\rangle} (-4J_{ij}x_ix_j +2J_{ij}x_i +2J_{ij}x_j -J_{ij}) +\sum_{j}(2\mu h_jx_j-\mu h_j) &&\text{using } x_j=x_jx_j\\
&= \sum_{\langle i~j\rangle} (-4J_{ij}x_ix_j) + \sum_{\langle i~j\rangle}2J_{ij}x_i + \sum_{\langle i~j\rangle}2J_{ij}x_j +\sum_{j}2\mu h_jx_j -\sum_{\langle i~j\rangle}J_{ij} -\sum_{j}\mu h_j\\
&= \sum_{\langle i~j\rangle} (-4J_{ij}x_ix_j) + \sum_{\langle j~i\rangle}2J_{ji}x_j + \sum_{\langle i~j\rangle}2J_{ij}x_j +\sum_{j}2\mu h_jx_j -\sum_{\langle i~j\rangle}J_{ij} -\sum_{j}\mu h_j &&\text{using } \sum_{\langle i~j\rangle}=\sum_{\langle j~i\rangle}\\
&= \sum_{\langle i~j\rangle} (-4J_{ij}x_ix_j) + \sum_j\sum_{\langle k=j~i\rangle}2J_{ki}x_j + \sum_j\sum_{\langle i~k=j\rangle}2J_{ik}x_j +\sum_{j}2\mu h_jx_j -\sum_{\langle i~j\rangle}J_{ij} -\sum_{j}\mu h_j\\
&= \sum_{\langle i~j\rangle} (-4J_{ij}x_ix_j) + \sum_j \left(\sum_{\langle i~k=j\rangle}(2J_{ki} + 2J_{ik}) + 2\mu h_j \right)x_j -\sum_{\langle i~j\rangle}J_{ij} -\sum_{j}\mu h_j &&\text{using } \sum_{\langle k=j~i\rangle}=\sum_{\langle i~k=j\rangle}\\
&= \sum_{i=1}^n\sum_{j=1}^i Q_{ij}x_ix_j + C\end{align}</math>
where
: <math>\begin{align}Q_{ij} &= \begin{cases}-4J_{ij} &\text{if } i\neq j \\
\sum_{\langle i~k=j\rangle}(2J_{ki} + 2J_{ik}) + 2\mu h_j &\text{if } i=j\end{cases} \\
C &= -\sum_{\langle i~j\rangle}J_{ij} -\sum_{j}\mu h_j\end{align}</math>
and using the fact that for a binary variable <math> x_j = x_j x_j </math>.

As the constant <math>C</math> does not change the position of the optimum <math>x^*</math>, it can be neglected during optimization and is only important for recovering the original Hamiltonian function value.

==References==

{{Reflist|refs=
<ref name="punnen2022">A. P. Punnen (editor), Quadratic unconstrained binary optimization problem: Theory, Algorithms, and Applications, Springer, Springer, 2022.</ref>
<ref name="cela2022">Çela, E., Punnen, A.P. (2022). Complexity and Polynomially Solvable Special Cases of QUBO. In: Punnen, A.P. (eds) The Quadratic Unconstrained Binary Optimization Problem. Springer, Cham. https://doi.org/10.1007/978-3-031-04520-2_3</ref>
}}

==External links==

*[http://plato.asu.edu/ftp/qubo.html QUBO Benchmark] (Benchmark of software packages for the exact solution of QUBOs; part of the well-known Mittelmann benchmark collection)

* {{cite journal
| url        = http://portal.acm.org/citation.cfm?id=1231283
| title      = Local search heuristics for Quadratic Unconstrained Binary Optimization (QUBO)
| journal    = Journal of Heuristics
| doi        = 10.1007/s10732-007-9009-3
| author     = Endre Boros, Peter L Hammer & Gabriel Tavares
| volume     =  13| issue = 2
| date       = April 2007
| pages      = 99–132
| publisher  = Association for Computing Machinery
| s2cid = 32887708
| access-date = 12 May 2013
}}
* {{cite journal
| title      = Analyzing quadratic unconstrained binary optimization problems via multicommodity flows
| journal    = Discrete Applied Mathematics
| author     = Di Wang & Robert Kleinberg
| volume     =  157| issue = 18
| date       = November 2009
| doi        = 10.1016/j.dam.2009.07.009
| pmid = 20161596
| pmc = 2808708
| pages      = 3746–3753
| publisher  = Elsevier
}}

[[Category:Machine learning algorithms]]


{{compu-AI-stub}}