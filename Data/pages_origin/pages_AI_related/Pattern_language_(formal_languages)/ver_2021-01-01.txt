In [[theoretical computer science]], a '''pattern language''' is a [[formal language]] that can be defined as the set of all particular instances of a [[string (formal languages)|string]] of constants and variables. Pattern Languages were introduced by [[Dana Angluin]] in the context of [[machine learning]].<ref>{{cite journal| author=Dana Angluin| title=Finding Patterns Common to a Set of Strings| journal=Journal of Computer and System Sciences| year=1980| volume=21| pages=46–62| doi=10.1016/0022-0000(80)90041-0}}</ref>

== Definition ==
Given a finite set Σ of '''[[Term (logic)#Formal definition|constant]]''' symbols and a countable set ''X'' of '''[[Term (logic)#Formal definition|variable]]''' symbols disjoint from Σ, a '''pattern''' is a finite [[empty string|non-empty]] [[String (computer science)|string]] of symbols from Σ∪''X''.
The '''length''' of a pattern ''p'', denoted by |''p''|, is just the number of its symbols.
The set of all patterns containing exactly ''n'' distinct variables (each of which may occur several times) is denoted by ''P''<sub>''n''</sub>, the set of all patterns at all by ''P''<sub>*</sub>.
A '''substitution''' is a mapping ''f'': ''P''<sub>*</sub> → ''P''<sub>*</sub> such that<ref group=note>Angluin's notion of substitution differs from the usual notion of [[string substitution]].</ref>
* ''f'' is a [[monoid homomorphism|homomorphism]] with respect to [[String_(computer_science)#Concatenation_and_substrings|string concatenation]] (⋅), formally: ∀''p'',''q''∈''P''<sub>*</sub>. ''f''(''p''⋅''q'') = ''f''(''p'')⋅''f''(''q'');
* ''f'' is non-erasing, formally: ∀''p''∈''P''<sub>*</sub>. ''f''(''p'') ≠ ε, where ε denotes the [[empty string]]; and
* ''f'' respects constants, formally: ∀''s''∈Σ. ''f''(''s'') = ''s''.
If ''p'' = ''f''(''q'') for some patterns ''p'', ''q'' ∈ ''P''<sub>*</sub> and some substitution ''f'', then ''p'' is said to be '''less general than''' ''q'', written ''p''≤''q'';
in that case, necessarily |''p''| ≥ |''q''| holds.
For a pattern ''p'', its '''language''' is defined as the set of all less general patterns that are built from constants only, formally: ''L''(''p'') = { ''s'' ∈ Σ<sup>+</sup> : ''s'' ≤ ''p'' }, where [[Kleene plus|Σ<sup>+</sup>]] denotes the set of all finite non-empty strings of symbols from Σ.

For example, using the constants Σ = { 0, 1 } and the variables ''X'' = { ''x'', ''y'', ''z'', ... }, the pattern 0''x''10''xx''1 ∈''P''<sub>1</sub> and ''xxy'' ∈''P''<sub>2</sub> has length 7 and 3, respectively.
An instance of the former pattern is 00''z''100''z''0''z''1 and 01''z''101''z''1''z''1, it is obtained by the substitution that maps ''x'' to 0''z'' and to 1''z'', respectively, and each other symbol to itself. Both 00''z''100''z''0''z''1 and 01''z''101''z''1''z''1 are also instances of ''xxy''. In fact, ''L''(0''x''10''xx''1) is a subset of ''L''(''xxy''). The language of the pattern ''x''0 and ''x''1 is the set of all bit strings which denote an even and odd [[binary number]], respectively. The language of ''xx'' is the set of all strings obtainable by concatenating a bit string with itself, e.g. 00, 11, 0101, 1010, 11101110 ∈ ''L''(''xx'').

== Properties ==
{| style="float:right"
| [[File:NP-hardness of pattern language membership svg.svg|thumb|600px|NP-hardness of pattern language membership, by [[Reduction (complexity)|reduction]] from the [[NP-complete]] [[Boolean_satisfiability_problem#Exactly-1_3-satisfiability|1-in-3-SAT problem]]: Given a [[Conjunctive normal form|CNF]] of ''m'' clauses with ''n'' variables, a pattern of length 3''n''+4''m''+1 with 2''n'' variables and a string of length ''4''n+5''m''+1 can be constructed as shown (''m''=3 and ''n''=4 in the example). Upper-case variables in the pattern correspond to negated variables in the CNF.  The string matches the pattern if and only if an assignment exists such that in each clause exactly one literal is 1 (meaning "''true''" in the CNF). In the left part, e.g. "0''wW''0" is matched by "01110" just if one of ''w'',''W'' is matched by "1" (corresponding to "''false''") and the other by "11" (corresponding to "''true''"), i.e. if ''w'' corresponds to the negation of ''W''. In the right part, e.g. "0''xYZ''0" is matched by "011110" just if exactly one of ''x'',''Y'',''Z'' is matched by "11" and the others by "1", i.e. if exactly one literal corresponds to "''true''".]]
|}
The problem of deciding whether ''s'' ∈ ''L''(''p'') for an arbitrary string ''s'' ∈ Σ<sup>+</sup> and pattern ''p'' is [[NP-complete]] (see picture),
and so is hence the problem of deciding ''p'' ≤ ''q'' for arbitrary patterns ''p'', ''q''.<ref>Theorem 3.6, p.50; Corollary 3.7, p.52</ref>

The class of pattern languages is '''not closed''' under ...
* union: e.g. for Σ = {0,1} as [[#Definition|above]], ''L''(01)∪''L''(10) is not a pattern language;
* complement: Σ<sup>+</sup> \ ''L''(0) is not a pattern language;
* intersection: ''L''(''x''0''y'')∩''L''(''x''1''y'') is not a pattern language;
* [[Kleene plus]]: ''L''(0)<sup>+</sup> is not a pattern language;
* homomorphism: ''f''(''L''(''x'')) = ''L''(0)<sup>+</sup> is not a pattern language, assuming ''f''(0) = 0 = ''f''(1);
* [[String_operations#String_homomorphism|inverse homomorphism]]: ''f''<sup>−1</sup>(111) = { 01, 10, 000 } is not a pattern language, assuming ''f''(0) = 1 and ''f''(1) = 11.
The class of pattern languages is '''closed''' under ...
* concatenation: ''L''(''p'')⋅''L''(''q'') = ''L''(''p''⋅''q'');
* reversal: ''L''(''p'')<sup>rev</sup> = ''L''(''p''<sup>rev</sup>).<ref>Theorem 3.10, p.53</ref>

If ''p'', ''q'' ∈ ''P''<sub>1</sub> are patterns containing exactly one variable, then ''p'' ≤ ''q'' if and only if ''L''(''p'') ⊆ ''L''(''q'');
the same equivalence holds for patterns of equal length.<ref>Lemma 3.9, p.52; Corollary 3.4, p.50</ref>
For patterns of different length, the [[#Definition|above]] example ''p'' = 0''x''10''xx''1 and ''q'' = ''xxy'' shows that ''L''(''p'') ⊆ ''L''(''q'') may hold without implying ''p'' ≤ ''q''.
However, any two patterns ''p'' and ''q'', of arbitrary lengths, generate the same language if and only if they are equal up to consistent variable renaming.<ref>Theorem 3.5, p.50</ref>
Each pattern ''p'' is a [[Anti-unification_(computer_science)#Anti-unification_problem.2C_generalization_set|common generalization]] of all strings in its generated language ''L''(''p''), modulo associativity of (⋅).

==Location in the Chomsky hierarchy==
In a refined [[Chomsky hierarchy]], the class of pattern languages is a proper superclass and subclass of the singleton<ref group=note>i.e. languages consisting of a single string; they correspond to [[straight-line grammar]]s</ref> and the [[indexed language]]s, respectively, but incomparable to the language classes in between; due to the latter, the pattern language class is not explicitly shown in the table [[#References|below]].

The class of pattern languages is incomparable with the class of [[finite language]]s, with the class of [[regular language]]s, and with the class of [[context-free language]]s:
* the pattern language ''L''(''xx'') is not context-free (hence neither [[Regular language#Deciding whether a language is regular|regular]] nor [[Regular language#Formal definition|finite]]) due to the [[pumping lemma for context-free languages|pumping lemma]];
* the finite (hence also regular and context-free) language { 01, 10 } is not a pattern language.
Each singleton language is trivially a pattern language, generated by a pattern without variables.

Each pattern language can be produced by an [[indexed grammar]]:
For example, using Σ = { ''a'', ''b'', ''c'' } and ''X'' = { '''''x''''', '''''y''''' },
the pattern ''a'' '''''x''''' ''b'' '''''y''''' ''c'' '''''x''''' ''a'' '''''y''''' ''b'' is generated by a grammar with nonterminal symbols ''N'' = { ''S''<sub>'''''x'''''</sub>, ''S''<sub>'''''y'''''</sub>, ''S'' } ∪ ''X'', terminal symbols ''T'' = Σ, index symbols ''F'' = { ''a''<sub>'''''x'''''</sub>, ''b''<sub>'''''x'''''</sub>, ''c''<sub>'''''x'''''</sub>, ''a''<sub>'''''y'''''</sub>, ''b''<sub>'''''y'''''</sub>, ''c''<sub>'''''y'''''</sub> }, start symbol ''S''<sub>'''''x'''''</sub>, and the following production rules:
{|
|-
| ''S''<sub>'''''x'''''</sub>[σ] 
| →   ''S''<sub>'''''x'''''</sub>[''a''<sub>'''''x'''''</sub> σ]
| | | ''S''<sub>'''''x'''''</sub>[''b''<sub>'''''x'''''</sub> σ]
| | | ''S''<sub>'''''x'''''</sub>[''c''<sub>'''''x'''''</sub> σ]
| | | ''S''<sub>'''''y'''''</sub>[σ]
|-
| ''S''<sub>'''''y'''''</sub>[σ] 
| →   ''S''<sub>'''''y'''''</sub>[''a''<sub>'''''y'''''</sub> σ]
| | | ''S''<sub>'''''y'''''</sub>[''b''<sub>'''''y'''''</sub> σ]
| | | ''S''<sub>'''''y'''''</sub>[''c''<sub>'''''y'''''</sub> σ]
| | | ''S''[σ] 
|-
| ''S''[σ] 
| colspan=4 | → ''a'' '''''x'''''[σ] ''b'' '''''y'''''[σ] ''c'' '''''x'''''[σ] ''a'' '''''y'''''[σ] ''b''
|}
{|
|-
| '''''x'''''[''a''<sub>'''''x'''''</sub> σ] || → ''a'' || '''''x'''''[σ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
| '''''y'''''[''a''<sub>'''''x'''''</sub> σ] || →       || '''''y'''''[σ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
|-
| '''''x'''''[''b''<sub>'''''x'''''</sub> σ] || → ''b'' || '''''x'''''[σ]
| '''''y'''''[''b''<sub>'''''x'''''</sub> σ] || →       || '''''y'''''[σ]
|-
| '''''x'''''[''c''<sub>'''''x'''''</sub> σ] || → ''c'' || '''''x'''''[σ]
| '''''y'''''[''c''<sub>'''''x'''''</sub> σ] || →       || '''''y'''''[σ]
|-
| '''''x'''''[''a''<sub>'''''y'''''</sub> σ] || →       || '''''x'''''[σ]
| '''''y'''''[''a''<sub>'''''y'''''</sub> σ] || → ''a'' || '''''y'''''[σ]
|-
| '''''x'''''[''b''<sub>'''''y'''''</sub> σ] || →       || '''''x'''''[σ]
| '''''y'''''[''b''<sub>'''''y'''''</sub> σ] || → ''b'' || '''''y'''''[σ]
|-
| '''''x'''''[''c''<sub>'''''y'''''</sub> σ] || →       || '''''x'''''[σ]
| '''''y'''''[''c''<sub>'''''y'''''</sub> σ] || → ''c'' || '''''y'''''[σ]
|-
| '''''x'''''[] || → ε ||
| '''''y'''''[] || → ε
|}

An example derivation is:

{{nowrap|''S''<sub>'''''x'''''</sub>[]}}
&nbsp; ⇒ &nbsp; {{nowrap|''S''<sub>'''''x'''''</sub>[''b''<sub>'''''x'''''</sub>]}}
&nbsp; ⇒ &nbsp; {{nowrap|''S''<sub>'''''x'''''</sub>[''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>]}}
&nbsp; ⇒ &nbsp; {{nowrap|''S''<sub>'''''y'''''</sub>[''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>]}}
&nbsp; ⇒ &nbsp; {{nowrap|''S''<sub>'''''y'''''</sub>[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>]}}
&nbsp; ⇒ &nbsp; {{nowrap|''S''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>]}}
&nbsp; ⇒  &nbsp; {{nowrap|''a'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''c'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒  &nbsp; {{nowrap|''a'' '''''x'''''[''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''c'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒  &nbsp; {{nowrap|''a'' ''a'' '''''x'''''[''b''<sub>'''''x'''''</sub>] ''b'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''c'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒  &nbsp; {{nowrap|''a'' ''ab'' '''''x'''''[] ''b'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''c'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒  &nbsp; {{nowrap|''a'' ''ab'' ''b'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''c'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒ ... ⇒ &nbsp; {{nowrap|''a'' ''ab'' ''b'' ''c'' '''''y'''''[] ''c'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒ &nbsp; {{nowrap|''a'' ''ab'' ''b'' ''c'' ''c'' '''''x'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒ ... ⇒ &nbsp; {{nowrap|''a'' ''ab'' ''b'' ''c'' ''c'' ''ab'' '''''x'''''[] ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒ &nbsp; {{nowrap|''a'' ''ab'' ''b'' ''c'' ''c'' ''ab'' ''a'' '''''y'''''[''c''<sub>'''''y'''''</sub> ''a''<sub>'''''x'''''</sub> ''b''<sub>'''''x'''''</sub>] ''b''}}
&nbsp; ⇒ ... ⇒ &nbsp; {{nowrap|''a'' ''ab'' ''b'' ''c'' ''c'' ''ab'' ''a'' ''c'' '''''y'''''[] ''b''}}
&nbsp; ⇒ &nbsp; {{nowrap|''a'' ''ab'' ''b'' ''c'' ''c'' ''ab'' ''a'' ''c'' ''b''}}

In a similar way, an index grammar can be constructed from any pattern.

== Learning patterns ==
Given a sample set ''S'' of strings, a pattern ''p'' is called '''descriptive''' of ''S'' if ''S'' ⊆ ''L''(''p''), but not ''S'' ⊆ ''L''(''q'') ⊂ ''L''(''p'') for any other pattern ''q''.

Given any sample set ''S'', a descriptive pattern for ''S'' can be computed by 
* enumerating all patterns (up to variable renaming) not longer than the shortest string in ''S'',
* selecting from them the patterns that generate a superset of ''S'',
* selecting from them the patterns of maximal length, and 
* selecting from them a pattern that is minimal with respect to ≤.<ref>Theorem 4.1, p.53</ref>
Based on this algorithm, the class of pattern languages can be [[Language identification in the limit|identified in the limit]] from positive examples.<ref>{{cite journal| author=Dana Angluin| title=Inductive Inference of Formal Languages from Positive Data| journal=Information and Control| year=1980| volume=45| issue=2| pages=117–135| url=http://www-personal.umich.edu/~yinw/papers/Angluin80.pdf| doi=10.1016/s0019-9958(80)90285-5}}; here: Example 1, p.125</ref>

==Notes==
{{reflist|group=note}}
== References ==
{{reflist}}
{{formal languages and grammars}}

[[Category:Formal languages]]
[[Category:Theoretical computer science]]
[[Category:Machine learning]]