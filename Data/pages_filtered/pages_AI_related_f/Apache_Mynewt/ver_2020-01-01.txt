Apache Mynewt is a modular real-time operating system for connected Internet of things (IoT) devices that must operate for long times under power, memory, and storage constraints. It is free and open-source software incubating under the Apache Software Foundation, with source code distributed under the Apache License 2.0, a permissive license that is conducive to commercial adoption of open-source software.

 Overview 
Apache Mynewt is a real-time operating system with a rich set of libraries intended to make prototyping, deploying, and managing 32-bit microcontroller based IoT devices easy. It is highly composable, to allow building embedded system applications (e.g., locks, medical devices, industrial IoT) across different types of microcontrollers. The name Mynewt is wordplay on the English word minute, meaning very small: the kernel is only 6 KB in size.

The OS is designed for connectivity, and comes with a full implementation of the Bluetooth low energy 4.2 stack. With the addition of BLE (supporting all Bluetooth 4.2 compliant security features except privacy) and various utilities such as the default file system, console, shell, logs, stats, etc., the image size is approximately 96 KB for the Nordic nRF51822 Bluetooth SoC. This size metric excludes the boot loader image.

 Core features 
The core operating system supports:[3]
 Preemptive multithreading
 Tickless priority based scheduling
 Programmable timers
 System time
 Semaphores
 Mutexes
 Event queues
 Memory management (allocation): dynamic (heap) and pool
 Multi-stage software watchdog timer 
 Memory or data buffers, to hold packet data as it moves up and down the networking protocol stack
Other features and utilities include:
 Hardware abstraction layer with support for CPU time, analog-to-digital converter (ADC), digital-to-analog converter (DAC), general-purpose input/output (GPIO), Inter-Integrated Circuit (IÂ²C), pulse-width modulation (PWM), serial port, Serial Peripheral Interface Bus (SPI), universal asynchronous receiver/transmitter (UART).
 Newtron flash file system (nffs) with minimal RAM usage and reliability features
 File system abstraction to allow client code to choose alternate file systems
 Console access and shell package
 Secure boot loader and image organizer (manager) that includes image integrity verification using SHA-256 and optional digital signature verification of images before running them
 Test utilities to build regression testing
 Statistics and logs for all major packages
 JavaScript Object Notation (JSON) encoder and decoder libraries
 Lua interpreter

 Bluetooth low energy 
The first network stack available in Mynewt is Bluetooth low energy and is called NimBLE. It complies with Bluetooth Core Specification 4.2.Bluetooth Core Specification 4.2

NimBLE includes both the host and controller components. Access to the controller source code makes the BLE performance highly configurable. For example, the BLE throughput can be adjusted by changing the connection intervals, data packet size, packet queue size etc. A use case requiring a large number of concurrent connections can similarly be configured, provided there is adequate RAM allocated. Example applications that demonstrate how to use available services are included in the package.

 Supported boards 
The operating system is designed for cross-platform use in embedded systems (devices) and microcontrollers. It includes board support packages for the following, :
 nRF52832 Bluetooth SoC from Nordic Semiconductor
 nRF51822/nRF51422 Bluetooth SoC from Nordic Semiconductor
 STM32F3DISCOVERY with STM32F3xx series Cortex-M4 from ST
 STM32-E407 for STM32F407ZGT6 Cortex M4 from ST
 Arduino Zero and Zero Pro
 Arduino M0 Pro with ATSAMD21G18 Cortex M0
 Arduino 101, Bluetooth controller only
 Arduino Primo, Bluetooth controller and host

 Package management 
The project includes the Newt Tool which is a command-line interface (CLI) based smart source package manager system for embedded systems development. Also, it allows composing builds with specified packages and compiler options, generating images and their digital signatures, and finally downloading and debugging the firmware on different targets.