Julia is a high-level, high-performance, dynamic programming language. While it is a general-purpose language and can be used to write any application, many of its features are well suited for numerical analysis and computational science.

Distinctive aspects of Julia's design include a type system with parametric polymorphism in a dynamic programming language; with multiple dispatch as its core programming paradigm. Julia supports concurrent, (composable) parallel and distributed computing (with or without using MPI or the built-in corresponding to "OpenMP-style" threads), and direct calling of C and Fortran libraries without glue code. Julia uses a just-in-time (JIT) compiler that is referred to as "just-ahead-of-time" (JAOT) in the Julia community, as Julia compiles all code (by default) to machine code before running it.

Julia is garbage-collected, uses eager evaluation, and includes efficient libraries for floating-point calculations, linear algebra, random number generation, and regular expression matching. Many libraries are available, including some (e.g., for fast Fourier transforms) that were previously bundled with Julia and are now separate.now available with using FFTW in current versions (That dependency, is one of many which, was moved out of the standard library to a package because it is GPL licensed, and thus is not included in Julia 1.0 by default.) 

Several development tools support coding in Julia, such as integrated development environments (e.g. Microsoft's Visual Studio Code, with extensions available adding Julia support to IDEs, e.g. providing debugging and linting support); with integrated tools, e.g. a profiler (and flame graph support available for the built-in one), debugger, and the Rebugger.jl package "supports repeated-execution debugging" and more.

History
Work on Julia was started in 2009, by Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and Alan Edelman, who set out to create a free language that was both high-level and fast. On 14 February 2012, the team launched a website with a blog post explaining the language's mission. In an interview with InfoWorld in April 2012, Karpinski said of the name "Julia": "There's no good reason, really. It just seemed like a pretty name." Bezanson said he chose the name on the recommendation of a friend, then years later wrote:

Since the 2012 launch, the Julia community has grown, and as of 2020 "Julia has been downloaded by users at more than 10,000 companies and is used at more than 1,500 universities" with over 29 million downloads , up by 87% in a year, and the Julia package ecosystem has over 11.8 million lines of code (including docs and tests). The JuliaCon academic conference for Julia users and developers has been held annually since 2014 with JuliaCon2020 welcoming over 28,900 unique viewers, and then JuliaCon2021 breaking all previous records (with more than 300 JuliaCon2021 presentations available for free on YouTube, up from 162 the year before), and 43,000 unique viewers during the conference.

Version 0.3 was released in August 2014, version 0.6 in June 2017. Both Julia 0.7 and version 1.0 were released on 8 August 2018. Work on Julia 0.7 was a "huge undertaking" (e.g., because of an "entirely new optimizer"), and some changes were made to semantics, e.g. the iteration interface was simplified; and the syntax changed a little (with the syntax now stable, and same for 1.x and 0.7).

Julia 1.0.0 was released on 8 August 2018. Bugfix releases are expected roughly monthly for supported versions, at the time Julia 1.0.1 up to 1.0.5 followed that schedule. Julia 1.1 was released in January 2019 with, e.g., a new "exception stack" language feature. Julia 1.2 was released in August 2019, and it has e.g. some built-in support for web browsers (for testing if running in JavaScript VM). Julia 1.3 added e.g. composable multi-threaded parallelism and a binary artifacts system for Julia packages.

Julia 1.4 allowed better syntax for array indexing to handle e.g. 0-based arrays, with  for the second element of array A. The memory model was also changed. Minor release 1.4.2 fixed e.g. a Zlib issue, doubling decompression speed.

Julia 1.5 released in August 2020 added record and replay debugging support, for Mozilla's rr tool.  It's a big release, with changed behavior in the REPL (soft scope), same as used in Jupyter, but fully compatible for non-REPL code. Most of the thread API was marked as stable, and with this release "arbitrary immutable objects—regardless of whether they have fields that reference mutable objects or not—can now be stack allocated", reducing heap allocations, e.g. views are no longer allocating.  All versions have worked on performance, but especially work on Julia 1.5 targeted so-called "time-to-first-plot" performance, in general, the speed of compilation itself (as opposed to performance of the generated code), and adds tools for developers to improve package loading. Julia 1.6 also improves such performance even more.

Packages that work in Julia 1.0.x should work in 1.1.x or newer, enabled by the forward compatible syntax guarantee. A notable exception was foreign language interface libraries like JavaCall.jl (for JVM languages like Java or Scala) and Rcall.jl (R language) due to some threading-related changes (at a time when all of the threading-functionality in Julia was marked experimental).  The issue was especially complicated for Java's JVM, as it has some special expectations around how the stack address space is used. A workaround called  was posted for Julia 1.3.0, while a full fix for Java is pending and has no set due date. In addition, JVM versions since Java 11 do not exhibit this problem.

Julia 1.6 was the largest release since 1.0, faster on many fronts, e.g. introduced parallel precompilation and faster loading of packages, in some cases "50x speedup in load times for large trees of binary artifacts".

Julia 1.6.4 was released on 19 November 2021, and it and 1.7.0 fixes a security issue. As of version 1.7 Julia development is back to time-based releases.

Julia 1.7.0 was released on 30 November 2021, with many changes, e.g. a new faster random-number generator (meaning users get a different stream of random numbers, unless they opt into using the older one, that is still also provided). Most users should use that release, but with it released 1.6 turned into the new long-term support (LTS) release, otherwise only the latest version, at each point in time, is supported, currently 1.7.0. Julia 1.8 is the next milestone. The milestone for 2.0 currently has no set due date.

Notable uses
Julia has attracted some high-profile users, from investment manager BlackRock, which uses it for time-series analytics, to the British insurer Aviva, which uses it for risk calculations. In 2015, the Federal Reserve Bank of New York used Julia to make models of the United States economy, noting that the language made model estimation "about 10 times faster" than its previous MATLAB implementation. Julia's co-founders established Julia Computing in 2015 to provide paid support, training, and consulting services to clients, though Julia remains free to use. At the 2017 JuliaCon conference, Jeffrey Regier, Keno Fischer and others announced that the Celeste project used Julia to achieve "peak performance of 1.54 petaFLOPS using 1.3 million threads" on 9300  Knights Landing (KNL) nodes of the Cori II (Cray XC40) supercomputer (then 6th fastest computer in the world). Julia thus joins C, C++, and Fortran as high-level languages in which petaFLOPS computations have been achieved.

Three of the Julia co-creators are the recipients of the 2019 James H. Wilkinson Prize for Numerical Software (awarded every four years) "for the creation of Julia, an innovative environment for the creation of high-performance tools that enable the analysis and solution of computational science problems." Also, Alan Edelman, professor of applied mathematics at MIT, has been selected to receive the 2019 IEEE Computer Society Sidney Fernbach Award "for outstanding breakthroughs in high-performance computing, linear algebra, and computational science and for contributions to the Julia programming language."

In 2019, Julia Computing announced "the availability of the Julia programming language as a pre-packaged container on the NVIDIA GPU Cloud (NGC) container registry" and a blog post at Nvidia's site states "Easily Deploy Julia on x86 and Arm [..] Julia offers a package for a comprehensive HPC ecosystem covering machine learning, data science, various scientific domains and visualization."

Additionally, "Julia was selected by the Climate Modeling Alliance as the sole implementation language for their next generation global climate model. This multi-million dollar project aims to build an earth-scale climate model providing insight into the effects and challenges of climate change."

Julia is used by NASA, e.g. for modeling spacecraft separation dynamics (15,000 times faster than before with Simulink/MATLAB) and the Brazilian INPE for space mission planning and satellite simulation. Another effort is working on an embedded project to control a satellite in space using Julia for attitude control.

JuliaCon
Since 2014, the Julia Community has hosted an annual Julia Conference focused on developers and users. The first JuliaCon took place in Chicago and kickstarted the annual occurrence of the conference. Since 2014, the conference has taken place across a number of locations including MIT and the University of Maryland, Baltimore. The event audience has grown from a few dozen people to over 28,900 unique attendees during JuliaCon 2020, which took place virtually. JuliaCon 2021 will take place virtually between July 28th and 30th 2021 with keynote addresses from Jan Vitek, Xiaoye Sherry Li, and Soumith Chintala.

Julia community
The Julia community has a presence across multiple platforms: Twitter, LinkedIn, Facebook, Slack, Zulip, Discord, Discourse, Stack Overflow, YouTube, and more. Since May 2017, the Julia Language has employed a community manager; first Alex Arslan who served until the end of 2019 and currently Logan Kilpatrick.

Sponsors
The Julia language became a NumFOCUS fiscally sponsored project in 2014 in an effort to ensure the project's long-term sustainability. Dr. Jeremy Kepner at MIT Lincoln Laboratory was the founding sponsor of the Julia project in its early days. In addition, funds from the Gordon and Betty Moore Foundation, the Alfred P. Sloan Foundation, Intel, and agencies such as NSF, DARPA, NIH, NASA, and FAA have been essential to the development of Julia. Mozilla, the maker of Firefox web browser, with its research grants for H1 2019, sponsored "a member of the official Julia team" for the project "Bringing Julia to the Browser", meaning to Firefox  and other web browsers. The Julia Language is also supported by individual donors on GitHub.

Julia Computing company
Julia Computing, Inc. was founded in 2015 by Viral B. Shah, Deepak Vinchhi, Alan Edelman, Jeff Bezanson, Stefan Karpinski and Keno Fischer.

In June 2017, Julia Computing raised US$4.6million in seed funding from General Catalyst and Founder Collective, the same month was "granted $910,000 by the Alfred P. Sloan Foundation to support open-source Julia development, including $160,000 to promote diversity in the Julia community", and in December 2019 the company got $1.1million funding from the US government to "develop a neural component machine learning tool to reduce the total energy consumption of heating, ventilation, and air conditioning (HVAC) systems in buildings". In July 2021, Julia Computing announced they raised a $24 million Series A led by Dorilton Ventures, which also owns Formula 1 team Williams Racing, that partnered with Julia Computing. Williams' Commercial Director said: "Investing in companies building best-in-class cloud technology is a strategic focus for Dorilton and Julia's versatile platform, with revolutionary capabilities in simulation and modelling, is hugely relevant to our business. We look forward to embedding Julia Computing in the world's most technologically advanced sport".

Language features
Julia is a general-purpose programming language, while also originally designed for numerical/technical computing.
It is also useful for low-level systems programming, as a specification language, and for web programming at both server and client side.

According to the official website, the main features of the language are:

 Multiple dispatch: providing ability to define function behavior across many combinations of argument types
 Dynamic type system: types for documentation, optimization, and dispatch
 Performance approaching that of statically-typed languages like C
 A built-in package manager
 Lisp-like macros and other metaprogramming facilities
 Call C functions directly: no wrappers or special APIs
 Ability to interface with other languages, e.g. Python with PyCall, R with RCall, and Java/Scala with JavaCall
 Powerful shell-like abilities to manage other processes
 Designed for parallel and distributed computing
 Coroutines: lightweight green threading
 User-defined types are as fast and compact as built-ins
 Automatic generation of efficient, specialized code for different argument types
 Elegant and extensible conversions and promotions for numeric and other types
 Efficient support for Unicode, including but not limited to UTF-8

Multiple dispatch (also termed multimethods in Lisp) is a generalization of single dispatch the polymorphic mechanism used in common object-oriented programming (OOP) languages that uses inheritance. In Julia, all concrete types are subtypes of abstract types, directly or indirectly subtypes of the Any type, which is the top of the type hierarchy. Concrete types can not themselves be subtyped the way they can in other languages; composition is used instead (see also inheritance vs subtyping).

By default, the Julia runtime must be pre-installed as user-provided source code is run. Alternatively, a standalone executable that needs no Julia source code can be built with PackageCompiler.jl.

Julia's syntactic macros (used for metaprogramming), like Lisp macros, are more powerful than text-substitution macros used in the preprocessor of some other languages such as C, because they work at the level of abstract syntax trees (ASTs). Julia's macro system is hygienic, but also supports deliberate capture when desired (like for anaphoric macros) using the esc construct.

Julia draws significant inspiration from various dialects of Lisp, including Scheme and Common Lisp, and it shares many features with Dylan, also a multiple-dispatch-oriented dynamic language (which features an ALGOL-like free-form infix syntax rather than a Lisp-like prefix syntax, while in Julia "everything" is an expression), and with Fortress, another numerical programming language (which features multiple dispatch and a sophisticated parametric type system). While Common Lisp Object System (CLOS) adds multiple dispatch to Common Lisp, not all functions are generic functions.

In Julia, Dylan, and Fortress, extensibility is the default, and the system's built-in functions are all generic and extensible. In Dylan, multiple dispatch is as fundamental as it is in Julia: all user-defined functions and even basic built-in operations like + are generic. Dylan's type system, however, does not fully support parametric types, which are more typical of the ML lineage of languages. By default, CLOS does not allow for dispatch on Common Lisp's parametric types; such extended dispatch semantics can only be added as an extension through the CLOS Metaobject Protocol. By convergent design, Fortress also features multiple dispatch on parametric types; unlike Julia, however, Fortress is statically rather than dynamically typed, with separate compiling and executing phases. The language features are summarized in the following table:

 Language  Type system  Generic functions  Parametric types Julia  Dynamic  Default   Common Lisp  Dynamic  Opt-in   Dylan  Dynamic  Default   (no dispatch) Fortress  Static  Default  

An example of the extensibility of Julia, the Unitful.jl package adds support for units of measure to the language.

Interaction
The Julia official distribution includes an interactive command-line read–eval–print loop (REPL), with a searchable history, tab completion, and dedicated help and shell modes, which can be used to experiment and test code quickly. The following fragment represents a sample session example where strings are concatenated automatically by println:See also:  for string interpolation and the string(greet, ", ", whom, ".\n") example for preferred ways to concatenate strings.  Julia has the println and print functions, but also a @printf macro (i.e., not in function form) to eliminate run-time overhead of formatting (unlike the same function in C).

julia> p(x) = 2x^2 + 1; f(x, y) = 1 + 2p(x)y
julia> println("Hello world!", " I'm on cloud ", f(0, 4), " as Julia supports recognizable syntax!")
Hello world! I'm on cloud 9 as Julia supports recognizable syntax!

The REPL gives user access to the system shell and to help mode, by pressing ; or ? after the prompt (preceding each command), respectively. It also keeps the history of commands, including between sessions. Code that can be tested inside the Julia's interactive section or saved into a file with a .jl extension and run from the command line by typing:

 $ julia <filename>

Julia is supported by Jupyter, an online interactive "notebooks" environment, and Pluto.jl, a "reactive notebook" (where notebooks are saved as pure Julia files), a possible replacement for the former kind.

Use with other languages
Julia is in practice interoperable with many languages (e.g. majority of top 10–20 languages in popular use). Julia's ccall keyword is used to call C-exported or Fortran shared library functions individually, and packages to allow calling other languages e.g. Python, R, MATLAB, Java or Scala. And packages for other languages, e.g. Python (or R or Ruby), i.e. pyjulia, to call to Julia.

Julia has support for Unicode 13.0, with UTF-8 used for strings (by default) and for Julia source code (only allowing legal UTF-8 in the latest version), meaning also allowing as an option common math symbols for many operators, such as ∈ for the in operator.

Julia has packages supporting markup languages such as HTML (and also for HTTP), XML, JSON and BSON, and for databases and web use in general.

Package system
Julia has a built-in package manager and includes a default registry system. Packages are most often distributed as source code hosted on GitHub, though alternatives can also be used just as well. Packages can also be installed as binaries, using artifacts. Julia's package manager is used to query and compile packages, as well as managing environments. Federated package registries are supported, allowing registries other than the official to be added locally.

Implementation
Julia's core is implemented in Julia and C, together with C++ for the LLVM dependency. The parsing and code-lowering are implemented in FemtoLisp, a Scheme dialect. The LLVM compiler infrastructure project is used as the back end for generation of 64-bit or 32-bit optimized machine code depending on the platform Julia runs on. With some exceptions (e.g., PCRE), the standard library is implemented in Julia. The most notable aspect of Julia's implementation is its speed, which is often within a factor of two relative to fully optimized C code (and thus often an order of magnitude faster than Python or R). Development of Julia began in 2009 and an open-source version was publicized in February 2012.

Current and future platforms
While Julia has tier 1 macOS support, meaning for Intel-based Macs, the new Apple M1-based Macs only have tier 3 (experimental) support, with full support being worked on (neither does Windows on ARM). However, Julia is claimed to work "ok" on M1 Macs (at reduced performance) through the (automatic) use of Rosetta 2 (that needs to emulate Julia). Work on native full-speed M1 support (i.e. without emulation) is mostly done, and many programs may work if such a build of Julia is used, since all but one Julia tests pass (except for "Too many open files").

Since Julia uses JIT, Julia generates native machine code directly, before a function is first run (i.e. a different approach than compiling to bytecode, that you distribute by default, to be run on a virtual machine (VM), as with e.g. Java/JVM; then translated from the bytecode while running, as done by Dalvik on older versions of Android).

Julia has four support tiers. All IA-32 processors completely implementing the i686 subarchitecture are supported and 64-bit x86-64 (aka amd64), i.e. all less than about a decade old are supported. ARMv8 (AArch64) processors are supported on second tier, and ARMv7 and ARMv6 (AArch32) are supported with some caveats (lower tier) for Julia 1.0.x and also had official executables for later versions, while 32-bit ARM support was later downgraded to tier 3 (however, unofficial binaries are available for Julia 1.5.1). CUDA (i.e. Nvidia GPUs; implementing PTX) has tier 1 support, with the help of an external package. There are also additionally packages supporting other accelerators, such as Google's TPUs, and some Intel (integrated) GPUs, through oneAPI.jl, and AMD's GPUs have support with e.g. OpenCL; and experimental support for the AMD ROCm stack. Julia's downloads page provides executables (and source) for all the officially supported platforms.

On some platforms, Julia may need to be compiled from source code (e.g., the original Raspberry Pi), with specific build options, which has been done and unofficial pre-built binaries (and build instructions) are available. Julia has been built 
on several ARM platforms. PowerPC (64-bit) has tier 3 support, meaning it "may or may not build".

Julia is now supported in Raspbian while support is better for newer Pis, e.g., those with ARMv7 or newer; the Julia support is promoted by the Raspberry Pi Foundation.

There is also support for web browsers/JavaScript through JSExpr.jl; and the alternative language of web browsers, WebAssembly, has minimal support for several upcoming external Julia projects.

Julia can compile to ARM; thus, in theory, Android apps can be made with the NDK, but for now Julia has been made to run under Android only indirectly, i.e. with a Ubuntu chroot on Android.