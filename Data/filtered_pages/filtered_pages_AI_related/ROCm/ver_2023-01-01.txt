ROCm is an Advanced Micro Devices (AMD) software stack for graphics processing unit (GPU) programming. ROCm spans several domains: general-purpose computing on graphics processing units (GPGPU), high performance computing (HPC), heterogeneous computing. It offers several programming models: HIP (GPU-kernel-based programming), OpenMP/Message Passing Interface (MPI) (directive-based programming), OpenCL.

ROCm is free, libre and open-source software (except the GPU firmware blobs), it is distributed under various licenses.

 Background 
The first GPGPU software stack from ATI/AMD was Close to Metal, which became Stream.

ROCm was launched around 2016 with the Boltzmann Initiative. ROCm stack builds upon previous AMD GPU stacks, some tools trace back to GPUOpen, others to the Heterogeneous System Architecture (HSA).

Heterogeneous System Architecture
HSA was aimed at producing a middle-level, hardware-agnostic intermediate representation, that could be JIT-compiled to the eventual hardware (GPU, FPGA...) using the appropriate finalizer. This approach was dropped for ROCm: now it builds only GPU code, using LLVM, and its AMDGPU backend that was upstreamed, although there is still research on such enhanced modularity with LLVM MLIR.

Microsoft AMP C++ 1.2

 Programming abilities 

ROCm as a stack ranges from the kernel driver to the end-user applications.
AMD has introductory videos about AMD GCN hardware, and ROCm programming via its learning portal.

One of the best technical introductions about the stack and ROCm/HIP programming, remains, to date, to be found on Reddit.

High-level programming

HIP programming
HIP(HCC) kernel language
Memory allocation
NUMA
Heterogeneous Memory Model and Shared Virtual Memory

ROCm code objects
Compute/Graphics interop

Low-level programming

 Hardware support 
ROCm is primarily targeted at discrete professional GPUs, but , but unofficial support includes Vega-family and RDNA2 consumer GPUs.

Accelerated Processor Units (APU) are "enabled", but not officially supported. Having ROCm functional there is involved.

 Professional-grade GPUs 
AMD Instinct accelerators are the first-class ROCm citizens, alongside the prosumer Radeon Pro GPU series: they mostly see full support.

The only consumer-grade GPU that has relatively equal support is, as of January 2022, the Radeon VII (GCN 5 - Vega).

 Consumer-grade GPUs 
 Name of GPU series SouthernIslands SeaIslands VolcanicIslands ArcticIslands/Polaris Vega Navi 1X Navi 2X Released Jan 2012 Sep 2013 Jun 2015 Jun 2016 Jun 2017 Jul 2019 Nov 2020 Marketing Name Radeon HD 7000 Radeon Rx 200 Radeon Rx 300 Radeon RX 400/500 Radeon RX Vega/Radeon VII(7 nm) Radeon RX 5000 Radeon RX 6000 AMD support colspan="3"   colspan=4  Instruction set GCN instruction set RDNA instruction set Microarchitecture GCN 1st gen GCN 2nd gen  GCN 3rd gen  GCN 4th gen GCN 5th gen RDNA RDNA 2 TypeUnified shader model ROCm  colspan=4  colspan=1  colspan=1  colspan=2  OpenCL1.2 (on Linux: 1.1 (no Image support) with Mesa 3D) 2.0 (Adrenalin driver on Win7+)(on Linux: 1.1 (no Image support) with Mesa 3D, 2.0 with AMD drivers or AMD ROCm) 2.0 2.1  Vulkan 1.0(Win 7+ or Mesa 17+) 1.2 (Adrenalin 20.1, Linux Mesa 3D 20.0) Shader model 5.1 5.16.3 6.4 6.5 OpenGL 4.6 (on Linux: 4.6 (Mesa 3D 20.0)) Direct3D 11 (11_1)12 (11_1) 11 (12_0)12 (12_0) 11 (12_1)12 (12_1) 11 (12_1)12 (12_2) /drm/amdgpu colspan=2  colspan=5 

 Software ecosystem 
 Learning resources 

AMD ROCm product manager gave a tour of the stack.

 Third-party integration 
The main consumers of the stack are machine learning and high-performance computing/GPGPU applications.

 Machine learning 
Various Deep Learning frameworks have a ROCm backend:
 PyTorch
 TensorFlow
 ONNX
 MXNet
 CuPy
 MIOpen
 Caffe
 Iree (which uses LLVM Multi-Level Intermediate Representation (MLIR))

 Supercomputing 
ROCm is gaining significant traction in the top 500.
ROCm is used with the Exascale supercomputers ElCapitan and Frontier.

Some related software is to be found at AMD Infinity hub.

 Other acceleration & graphics interoperation 
As of version 3.0, Blender can now use HIP compute kernels for its renderer Cycles.

 Other Languages 

 Julia 

Julia has the AMDGPU.jl package, which integrates with LLVM and selects components of the ROCm stack. Instead of compiling code through HIP, AMDGPU.jl uses Julia's compiler to generate LLVM IR directly, which is later consumed by LLVM to generate native device code. AMDGPU.jl uses ROCr's HSA implementation to upload native code onto the device and execute it, similar to how HIP loads its own generated device code.

AMDGPU.jl also supports integration with ROCm's rocBLAS (for BLAS), rocRAND (for random number generation), and rocFFT (for FFTs). Future integration with rocALUTION, rocSOLVER, MIOpen, and certain other ROCm libraries is planned.

 Software distribution 
 Official 
ROCm software is currently spread across dozens of public GitHub repositories. Within the main public meta-repository, there is an xml manifest for each official release: using git-repo, a version control tool built on top of git, is the recommended way to synchronize with the stack locally.

The release of ROCm 5.1 is imminent, probably mid-February given a minor release each month.

+Stack areaPublic GitHub organisationLow-level (mostly)https://github.com/radeonopencomputeMid-level (mostly)https://github.com/rocm-developer-toolsHigh-level (mostly)https://github.com/rocmsoftwareplatform/
AMD starts distributing containerized applications for ROCm, notably scientific research applications gathered under AMD Infinity Hub.

AMD distributes itself packages tailored to various Linux distributions.

 Third-party 
There is a growing third-party ecosystem packaging ROCm.

Linux distributions are packaging officially (natively) ROCm, with various degrees of advancement: Arch, Gentoo, Debian and Fedora, GNU Guix, NixOS.

There are spack packages.

 Components 

There is one kernel-space component, ROCk, and the rest - there is roughly a hundred components in the stack - is made of user-space modules.

The unofficial typographic policy is to use: uppercase ROC lowercase following for low-level libraries, i.e. ROCt, and the contrary for user-facing libraries, i.e. rocBLAS.

AMD is active developing with the LLVM community, but upstreaming is not instantaneous, and as of January 2022, still lagging. AMD still packages officially various LLVM forks for parts that are not yet upstreamed - compiler optimizations destined to remain proprietary, debug support, OpenMP offloading...

 Low-level 
 ROCk - Kernel driver 

 ROCm - Device libraries 
Support libraries implemented as LLVM bitcode. These provide various utilities and functions for math operations, atomics, queries for launch parameters, on-device kernel launch, etc.

 ROCt - Thunk 
The thunk is responsible for all the thinking and queuing that goes into the stack.

 ROCr - Runtime 
The ROC runtime is different from the ROC Common Language Runtime in that it is not the same thing.

 ROCm - CompilerSupport 
ROCm code object manager is in charge of interacting with LLVM intermediate representation.

 Mid-level 
 ROCclr Common Language Runtime 
The common language runtime is an indirection layer adapting calls to ROCr on linux and PAL on windows.
It used to be able to route between different compilers like the HSAIL-compiler. It is now being absorbed by the upper indirection layers (HIP, OpenCL).

OpenCL

ROCm ships its Installable Client Driver ICD loader and an OpenCL implementation bundled together.
As of January 2022, ROCm 4.5.2 ships OpenCL 2.2, and is lagging behind competition.

 HIP - Heterogeneous Interface for Portability 
The AMD implementation for its GPUs is called HIPAMD. There is also a CPU implementation mostly for demonstration purposes.

 HIPCC 
HIP builds a `HIPCC` compiler that either wraps Clang and compiles with LLVM open AMDGPU backend, or redirects to the NVIDIA compiler.

 HIPIFY 
HIPIFY is a source-to-source compiling tool, it translates CUDA to HIP and reverse, either using a clang-based tool, or a sed-like Perl script.

 GPUFORT 
Like HIPIFY, GPUFORT is a tool compiling source code into other third-generation-language sources, allowing users to migrate from CUDA Fortran to HIP Fortran. It is also in the repertoire of research projects, even more so.

 High-level 
ROCm high-level libraries are usually consumed directly by application software, such as machine learning frameworks. Most of the following libraries are in the General Matrix Multiply (GEMM) category, which GPU architecture excels at.

The majority of these user-facing libraries comes in dual-form: hip for the indirection layer that can route to Nvidia hardware, and roc for AMD implementation.

 rocBLAS / hipBLAS 
rocBLAS and hipBLAS are central in high-level libraries, it is the AMD implementation for Basic Linear Algebra Subprograms.
It uses the library Tensile privately.

 rocSOLVER / hipSOLVER 
This pair of libraries constitutes the LAPACK implementation for ROCm and is strongly coupled to rocBLAS.

 Utilities 
 ROCm developer tools: Debug, tracer, profiler, System Management Interface, Validation suite, Cluster management.
 GPUOpen tools: GPU analyzer, memory visualizer...
 External tools: radeontop (TUI overview)

 Comparison with competitors 
ROCm is a competitor to similar stacks aimed at GPU computing: Nvidia CUDA and Intel OneAPI.

 NVidia CUDA 

Nvidia is close-source until cuBLAS and such high-level libraries.
Nvidia vendors the Clang frontend and its Parallel Thread Execution (PTX) LLVM GPU backend as the Nvidia CUDA Compiler (NVCC).
There is an open-source layer above it, for example RAPIDS.

 Intel OneAPI 