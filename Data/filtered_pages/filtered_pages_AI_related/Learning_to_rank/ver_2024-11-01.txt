Learning to rank. Slides from Tie-Yan Liu's talk at WWW 2009 conference are available online  or machine-learned ranking (MLR) is the application of machine learning, typically supervised, semi-supervised or reinforcement learning, in the construction of ranking models for information retrieval systems.Mehryar Mohri, Afshin Rostamizadeh, Ameet Talwalkar (2012) Foundations of Machine Learning, The
MIT Press . Training data may, for example, consist of lists of items with some partial order specified between items in each list. This order is typically induced by giving a numerical or ordinal score or a binary judgment (e.g. "relevant" or "not relevant") for each item. The goal of constructing the ranking model is to rank new, unseen lists in a similar way to rankings in the training data.

 Applications 

 In information retrieval 
250px|A possible architecture of a machine-learned search engine
Ranking is a central part of many information retrieval problems, such as document retrieval, collaborative filtering, sentiment analysis, and online advertising.

A possible architecture of a machine-learned search engine is shown in the accompanying figure.

Training data consists of queries and documents matching them together with the relevance degree of each match. It may be prepared manually by human assessors (or raters, as Google calls them), who check results for some queries and determine relevance of each result. It is not feasible to check the relevance of all documents, and so typically a technique called pooling is used — only the top few documents, retrieved by some existing ranking models are checked. This technique may introduce selection bias. Alternatively, training data may be derived automatically by analyzing clickthrough logs (i.e. search results which got clicks from users), query chains, or such search engines' features as Google's (since-replaced) SearchWiki. Clickthrough logs can be biased by the tendency of users to click on the top search results on the assumption that they are already well-ranked.

Training data is used by a learning algorithm to produce a ranking model which computes the relevance of documents for actual queries.

Typically, users expect a search query to complete in a short time (such as a few hundred milliseconds for web search), which makes it impossible to evaluate a complex ranking model on each document in the corpus, and so a two-phase scheme is used. First, a small number of potentially relevant documents are identified using simpler retrieval models which permit fast query evaluation, such as the vector space model, Boolean model, weighted AND, or BM25. This phase is called top- document retrieval and many heuristics were proposed in the literature to accelerate it, such as using a document's static quality score and tiered indexes.. Section 7.1  In the second phase, a more accurate but computationally expensive machine-learned model is used to re-rank these documents.

 In other areas 
Learning to rank algorithms have been applied in areas other than information retrieval:
 In machine translation for ranking a set of hypothesized translations;
 In computational biology for ranking candidate 3-D structures in protein structure prediction problems;
 In recommender systems for identifying a ranked list of related news articles to recommend to a user after he or she has read a current news article.Yuanhua Lv, Taesup Moon, Pranam Kolari, Zhaohui Zheng, Xuanhui Wang, and Yi Chang, Learning to Model Relatedness for News Recommendation , in International Conference on World Wide Web (WWW), 2011.

 Feature vectors 
For the convenience of MLR algorithms, query-document pairs are usually represented by numerical vectors, which are called feature vectors. Such an approach is sometimes called bag of features and is analogous to the bag of words model and vector space model used in information retrieval for representation of documents.

Components of such vectors are called features, factors or ranking signals. They may be divided into three groups (features from document retrieval are shown as examples):
 Query-independent or static features — those features, which depend only on the document, but not on the query. For example, PageRank or document's length. Such features can be precomputed in off-line mode during indexing. They may be used to compute document's static quality score (or static rank), which is often used to speed up search query evaluation.
 Query-dependent or dynamic features — those features, which depend both on the contents of the document and the query, such as TF-IDF score or other non-machine-learned ranking functions.
 Query-level features or query features, which depend only on the query. For example, the number of words in a query.

Some examples of features, which were used in the well-known  LETOR dataset:
 TF, TF-IDF, BM25, and language modeling scores of document's zones (title, body, anchors text, URL) for a given query;
 Lengths and IDF sums of document's zones;
 Document's PageRank, HITS ranks and their variants.

Selecting and designing good features is an important area in machine learning, which is called feature engineering.

 Evaluation measures 

There are several measures (metrics) which are commonly used to judge how well an algorithm is doing on training data and to compare the performance of different MLR algorithms. Often a learning-to-rank problem is reformulated as an optimization problem with respect to one of these metrics.

Examples of ranking quality measures:
Mean average precision (MAP);
 DCG and NDCG;
 Precision@n, NDCG@n, where "@n" denotes that the metrics are evaluated only on top n documents;
 Mean reciprocal rank;
 Kendall's tau;
 Spearman's rho.

DCG and its normalized variant NDCG are usually preferred in academic research when multiple levels of relevance are used. Other metrics such as MAP, MRR and precision, are defined only for binary judgments.

Recently, there have been proposed several new evaluation metrics which claim to model user's satisfaction with search results better than the DCG metric:
 Expected reciprocal rank (ERR);
 Yandex's pfound. (in Russian)
Both of these metrics are based on the assumption that the user is more likely to stop looking at search results after examining a more relevant document, than after a less relevant document.

 Approaches 

Tie-Yan Liu of Microsoft Research Asia has analyzed existing algorithms for learning to rank problems in his book Learning to Rank for Information Retrieval. He categorized them into three groups by their input spaces, output spaces, hypothesis spaces (the core function of the model) and loss functions: the pointwise, pairwise, and listwise approach. In practice, listwise approaches often outperform pairwise approaches and pointwise approaches. This statement was further supported by a large scale experiment on the performance of different learning-to-rank methods on a large collection of benchmark data sets.

In this section, without further notice,  denotes an object to be evaluated, for example, a document or an image,  denotes a single-value hypothesis,  denotes a bi-variate or multi-variate function and  denotes the loss function.

 Pointwise approach 
In this case, it is assumed that each query-document pair in the training data has a numerical or ordinal score. Then the learning-to-rank problem can be approximated by a regression problem — given a single query-document pair, predict its score. Formally speaking, the pointwise approach aims at learning a function  predicting the real-value or ordinal score of a document  using the loss function .

A number of existing supervised machine learning algorithms can be readily used for this purpose. Ordinal regression and classification algorithms can also be used in pointwise approach when they are used to predict the score of a single query-document pair, and it takes a small, finite number of values.

 Pairwise approach 
In this case, the learning-to-rank problem is approximated by a classification problem — learning a binary classifier  that can tell which document is better in a given pair of documents. The classifier shall take two documents as its input and the goal is to minimize a loss function . The loss function typically reflects the number and magnitude of inversions in the induced ranking.

In many cases, the binary classifier  is implemented with a scoring function . As an example, RankNet  adapts a probability model and defines  as the estimated probability of the document  has higher quality than :

where  is a cumulative distribution function, for example, the standard logistic CDF, i.e.

 Listwise approach 
These algorithms try to directly optimize the value of one of the above evaluation measures, averaged over all queries in the training data. This is often difficult in practice because most evaluation measures are not continuous functions with respect to ranking model's parameters, and so continuous approximations or bounds on evaluation measures have to be used. For example the SoftRank algorithm.Taylor, M.J., Guiver, J., Robertson, S.E., & Minka, T.P. (2008). SoftRank: optimizing non-smooth rank metrics. Web Search and Data Mining. LambdaMART is a pairwise algorithm which has been empirically shown to approximate listwise objective functions.

 List of methods 
A partial list of published learning-to-rank algorithms is shown below with years of first publication of each method:
{|class="wikitable sortable"
! Year || Name || Type || Notes
|-
| 1989 || OPRF || 2pointwise || Polynomial regression (instead of machine learning, this work refers to pattern recognition, but the idea is the same).
|-
| 1992 || SLR   || 2pointwise || Staged logistic regression.
|-
| 1994 || NMOpt   || 2listwise || Non-Metric Optimization.
|-
| 1999 || MART (Multiple Additive Regression Trees)|| 2pairwise ||
|-
| 2000 || Ranking SVM (RankSVM) || 2pairwise ||  A more recent exposition is in, which describes an application to ranking using clickthrough logs.
|-
| 2001 || Pranking|| 1pointwise || Ordinal regression.
|-
| 2003  || RankBoost || 2pairwise ||
|-
| 2005 || RankNet || 2pairwise ||
|-
| 2006 || IR-SVM|| 2pairwise || Ranking SVM with query-level normalization in the loss function.
|-
| 2006 || LambdaRank|| pairwise/listwise || RankNet in which pairwise loss function is multiplied by the change in the IR metric caused by a swap.
|-
| 2007 || AdaRank|| 3listwise ||
|-
| 2007 || FRank || 2pairwise || Based on RankNet, uses a different loss function - fidelity loss.
|-
| 2007 || GBRank || 2pairwise ||
|-
| 2007 || ListNet || 3listwise ||
|-
| 2007 || McRank || 1pointwise ||
|-
| 2007 || QBRank || 2pairwise ||
|-
| 2007 || RankCosine|| 3listwise ||
|-
| 2007 || RankGP|| 3listwise ||
|-
| 2007 || RankRLS || 2pairwise ||
Regularized least-squares based ranking. The work is extended in
 to learning to rank from general preference graphs.
|-
| 2007 || SVMmap || 3listwise ||
|-
| 2008 || LambdaSMART/LambdaMART|| pairwise/listwise || Winning entry in the Yahoo Learning to Rank competition in 2010, using an ensemble of LambdaMART models. Based on MART (1999)C. Burges. (2010). From RankNet to LambdaRank to LambdaMART: An Overview . “LambdaSMART”, for Lambda-submodel-MART, or LambdaMART for the case with no submodel.
|-
| 2008 || ListMLE|| 3listwise || Based on ListNet.
|-
| 2008 || PermuRank|| 3listwise ||
|-
| 2008 || SoftRank|| 3listwise ||
|-
| 2008 || Ranking RefinementRong Jin, Hamed Valizadegan, Hang Li, Ranking Refinement and Its Application for Information Retrieval , in International Conference on World Wide Web (WWW), 2008. || 2pairwise || A semi-supervised approach to learning to rank that uses Boosting.
|-
| 2008 || SSRankBoostMassih-Reza Amini, Vinh Truong, Cyril Goutte, A Boosting Algorithm for Learning Bipartite Ranking Functions with Partially Labeled Data , International ACM SIGIR conference, 2008. The code  is available for research purposes.  || 2pairwise|| An extension of RankBoost to learn with partially labeled data (semi-supervised learning to rank).
|-
| 2008 || SortNetLeonardo Rigutini, Tiziano Papini, Marco Maggini, Franco Scarselli, "SortNet: learning to rank by a neural-based sorting algorithm" , SIGIR 2008 workshop: Learning to Rank for Information Retrieval, 2008 || 2pairwise|| SortNet, an adaptive ranking algorithm which orders objects using a neural network as a comparator. 
|-
| 2009 || MPBoost|| 2pairwise || Magnitude-preserving variant of RankBoost. The idea is that the more unequal are labels of a pair of documents, the harder should the algorithm try to rank them.
|-
| 2009 || BoltzRank || 3listwise || Unlike earlier methods, BoltzRank produces a ranking model that looks during query time not just at a single document, but also at pairs of documents.
|-
| 2009 || BayesRank || 3listwise || A method combines Plackett-Luce Model and neural network to minimize the expected Bayes risk, related to NDCG, from the decision-making aspect.
|-
| 2010 || NDCG BoostHamed Valizadegan, Rong Jin, Ruofei Zhang, Jianchang Mao, Learning to Rank by Optimizing NDCG Measure , in Proceeding of Neural Information Processing Systems (NIPS), 2010. || 3listwise || A boosting approach to optimize NDCG.
|-
| 2010 || GBlend || 2pairwise || Extends GBRank to the learning-to-blend problem of jointly solving multiple learning-to-rank problems with some shared features.
|-
| 2010 || IntervalRank || 2pairwise & listwise ||
|-
| 2010 || CRR|| 2pointwise & pairwise || Combined Regression and Ranking. Uses stochastic gradient descent to optimize a linear combination of a pointwise quadratic loss and a pairwise hinge loss from Ranking SVM.
|-
| 2014 || LCR|| 2pairwise || Applied local low-rank assumption on collaborative ranking. Received best student paper award at WWW'14.
|-
|2015
|FaceNet
|pairwise
|Ranks face images with the triplet metric via deep convolutional network.
|-
|2016
|XGBoost
|pairwise
|Supports various ranking objectives and evaluation metrics.
|-
|2017 || ES-Rank|| listwise || Evolutionary Strategy Learning to Rank technique with 7 fitness evaluation metrics.
|-
| 2018 || DLCM   || 2listwise || A multi-variate ranking function that encodes multiple items from an initial ranked list (local context) with a recurrent neural network and create result ranking accordingly.
|-
|2018
|PolyRank
|pairwise
|Learns simultaneously the ranking and the underlying generative model from pairwise comparisons.
|-
|2018 || FATE-Net/FETA-Net|| listwise || End-to-end trainable architectures, which explicitly take all items into account to model context effects.
|-
|2019
|FastAPFatih Cakir, Kun He, Xide Xia, Brian Kulis, Stan Sclaroff, Deep Metric Learning to Rank , In Proc. IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2019.
|listwise
|Optimizes Average Precision to learn deep embeddings.
|-
|2019
|Mulberry || listwise & hybrid || Learns ranking policies maximizing multiple metrics across the entire dataset.
|-
|2019 
|DirectRanker || pairwise || Generalisation of the RankNet architecture. 
|-
| 2019 || GSF   || 2listwise || A permutation-invariant multi-variate ranking function that encodes and ranks items with groupwise scoring functions built with deep neural networks.
|-
|2020
|RaMBO
|listwise
|Optimizes rank-based metrics using blackbox backpropagation.
|-
|2020
|PRM|| pairwise || Transformer network encoding both the dependencies among items and the interactions between the user and items.
|-
| 2020 || SetRank   || 2listwise || A permutation-invariant multi-variate ranking function that encodes and ranks items with self-attention networks.
|-
|2021
|PiRank|| listwise || Differentiable surrogates for ranking able to exactly recover the desired metrics and scales favourably to large list sizes, significantly improving internet-scale benchmarks.
|-
|2022
|SAS-Rank
|listwise
|Combining Simulated Annealing with Evolutionary Strategy for implicit and explicit learning to rank from relevance labels.
|-
|2022
|VNS-Rank
|listwise
|Variable Neighborhood Search in 2 Novel Methodologies in AI for Learning to Rank.
|-
|2022
|VNA-Rank
|listwise
|Combining Simulated Annealing with Variable Neighbourhood Search for Learning to Rank.
|-
|2023
|GVN-Rank
|listwise
|Combining Gradient Ascent with Variable Neighbourhood Search for Learning to Rank.
|}

Note: as most supervised learning-to-rank algorithms can be applied to pointwise, pairwise and listwise case, only those methods which are specifically designed with ranking in mind are shown above.
 History 
Norbert Fuhr introduced the general idea of MLR in 1992, describing learning approaches in information retrieval as a generalization of parameter estimation; a specific variant of this approach (using polynomial regression) had been published by him three years earlier. Bill Cooper proposed logistic regression for the same purpose in 1992  and used it with his Berkeley research group to train a successful ranking function for TREC. Manning et al.. Sections 7.4  and 15.5  suggest that these early works achieved limited results in their time due to little available training data and poor machine learning techniques.

Several conferences, such as NeurIPS, SIGIR and ICML have had workshops devoted to the learning-to-rank problem since the mid-2000s (decade).

 Practical usage by search engines 
Commercial web search engines began using machine-learned ranking systems since the 2000s (decade). One of the first search engines to start using it was AltaVista (later its technology was acquired by Overture, and then Yahoo), which launched a gradient boosting-trained ranking function in April 2003.Jan O. Pedersen. The MLR Story 

Bing's search is said to be powered by RankNet algorithm, which was invented at Microsoft Research in 2005.

In November 2009 a Russian search engine Yandex announcedYandex corporate blog entry about new ranking model "Snezhinsk"  (in Russian) that it had significantly increased its search quality due to deployment of a new proprietary MatrixNet algorithm, a variant of gradient boosting method which uses oblivious decision trees.The algorithm wasn't disclosed, but a few details were made public in   and  . Recently they have also sponsored a machine-learned ranking competition "Internet Mathematics 2009" based on their own search engine's production data. Yahoo has announced a similar competition in 2010.

As of 2008, Google's Peter Norvig denied that their search engine exclusively relies on machine-learned ranking. Cuil's CEO, Tom Costello, suggests that they prefer hand-built models because they can outperform machine-learned models when measured against metrics like click-through rate or time on landing page, which is because machine-learned models "learn what people say they like, not what people actually like".

In January 2017, the technology was included in the open source search engine Apache Solr. It is also available in the open source OpenSearch and the source-available Elasticsearch. These implementations make learning to rank widely accessible for enterprise search.

 Vulnerabilities 
Similar to recognition applications in computer vision, recent neural network based ranking algorithms are also found to be susceptible to covert adversarial attacks, both on the candidates and the queries. With small perturbations imperceptible to human beings, ranking order could be arbitrarily altered. In addition, model-agnostic transferable adversarial examples are found to be possible, which enables black-box adversarial attacks on deep ranking systems without requiring access to their underlying implementations.

Conversely, the robustness of such ranking systems can be improved via adversarial defenses such as the Madry defense.